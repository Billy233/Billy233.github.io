<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OpenCV 算法笔记</title>
    <link href="/2024/06/18/cv/"/>
    <url>/2024/06/18/cv/</url>
    
    <content type="html"><![CDATA[<h2 id="一.图像矩阵基本操作">一.图像矩阵基本操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义</span><br>Z = np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">4</span>), np.uint8)<br><span class="hljs-comment"># 全是1 z = np.ones((2,4), np.int32)</span><br><br><span class="hljs-built_in">print</span>(z.shape)<br><span class="hljs-built_in">print</span>(z.dtype)<br><br>m=np.array([[<span class="hljs-number">14</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">114</span>, <span class="hljs-number">29</span>], [<span class="hljs-number">67</span>, <span class="hljs-number">23</span>, <span class="hljs-number">52</span>, <span class="hljs-number">2</span>]], np.float32)<br><br>m[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] <span class="hljs-comment">#第一行第三列 29</span><br>m[<span class="hljs-number">2</span>,:] <span class="hljs-comment">#第二行所有元素</span><br>m[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>, <span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br><span class="hljs-comment">#  12 3</span><br><span class="hljs-comment"># 12 114</span><br></code></pre></td></tr></table></figure><p>ndarray的加减法： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mat1+mat2<br></code></pre></td></tr></table></figure>注意对uchar类型的值超过255的数对255取模-1</p><p>点乘： mat1*mat2 或 np.multiply(m1, m2)</p><p>矩阵乘法： np.dot(m1, m2)</p><p>幂运算：np.power(m1, 2)</p><h2 id="二.仿射变换">二.仿射变换</h2><h3 id="空间坐标变换">2.1 空间坐标变换</h3><p>平移，放缩和旋转</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">src</span> = np.array([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">200</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">200</span>], np.float32)<br><span class="hljs-attribute">dst</span> = np.array([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">200</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">200</span>], np.float32)<br><br><span class="hljs-attribute">T</span> = cv.getAffineTransform(src, dst)<br></code></pre></td></tr></table></figure><p>其中 <span class="math inline">\(dst = T\cdot src\)</span></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">cv</span>.getRotationMatrix2D(<span class="hljs-built_in">center</span>, angle, <span class="hljs-built_in">scale</span>)<br></code></pre></td></tr></table></figure><p>center 变换中心坐标，angle角度值逆时针，scale放缩系数。</p><h3 id="插值算法">2.2 插值算法</h3><p>定义函数：<span class="math inline">\(I(y,x)\)</span> 是图像矩阵<span class="math inline">\(y\)</span> 行 <spanclass="math inline">\(x\)</span>列的值，定义二维函数：</p><p><span class="math display">\[z=f_I(x,y)=I(x,y)\]</span></p><p><span class="math display">\[ \begin{bmatrix} \hat{x}\\\hat{y}\\1\end{bmatrix} = A\begin{bmatrix} x\\y\\1 \end{bmatrix} \]</span></p><p>要计算 <span class="math inline">\(f_O在(\tilde{x},\tilde{y})处的值，0\leqslant \tilde{x}\leqslant \tilde{W} - 1,0\leqslant y \leqslant \tilde{H} - 1\)</span>，其中<spanclass="math inline">\(\tilde{W}\)</span>和<spanclass="math inline">\(\tilde{H}\)</span>是手动设定的值。</p><p><span class="math display">\[ \begin{bmatrix} x\\y\\1 \end{bmatrix}=  A^{-1}\begin{bmatrix} \hat{x}\\\hat{y}\\1 \end{bmatrix} \]</span></p><p>以放大两倍为例：<spanclass="math inline">\(f_O(3,3)=f_I(1.5,1.5)\)</span>，但无定义此时需要插值估算<spanclass="math inline">\(f_O(3,3)\)</span>处的值了。</p><p>需要注意的是 <span class="math inline">\((\tilde{x},\tilde{y})\)</span>逆仿射变换后的坐标 (𝑥, 𝑦)，如果 (𝑥, 𝑦) 落在 𝑓𝐼的定义域所在的矩形区域$[0, 𝑊 − 1] × [0, 𝐻 − 1]$内，则可以使用插值算法计算非整数坐 标处的函数值；如果(𝑥, 𝑦)落在第一象限的其他区域，甚至其他三个象限内，如图3-5中的第二种情况所示，那么就不需要用插值算法了，最常用的方法是直接令 <spanclass="math inline">\(𝑓_O(\tilde{x}, \tilde{y})\)</span>等于某一个预先设定好的常数即可。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/cv0.png" /></p><h4 id="最近邻插值">2.2.1 最近邻插值</h4><p>最近邻插值就是从(𝑥,𝑦)的四个相邻整数坐标中找到离它最近的一个，假设为(𝑥̂, 𝑦 )̂，然 后令 𝑓𝐼 (𝑥,𝑦) = 𝑓𝐼 (𝑥̂, 𝑦)̂ 。</p><p>举例：(2.3, 4.7) 的四个相邻整数坐标分别为(2, 4)、(3, 4)、(2, 5)、(3,5)，离它最近的是 (2, 5)，则函数𝑓𝐼 在(2.3, 4.7) 处的函数值等于<spanclass="math inline">\(f_I\)</span> 在(2, 5) 处的值，即<spanclass="math inline">\(f_I(2.3, 4.7) = f_I(2, 5)\)</span>。</p><p>使用最近邻插值方法完成图像几何变换，输出图像会出现锯齿状外观，对图像放大处理的效果会更明显。为了得到更好的效果，应使用更多的信息，而不仅仅使用最近像素的灰度值，常用的方法是双线性插值和三次样条插值。</p><h4 id="双线性插值">2.2.2双线性插值</h4><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/cv1.png" /></p><p>记 <span class="math inline">\(a = |x-|x||\)</span>， <spanclass="math display">\[f_I(x,[y])=af_I([x] +1,[y])+(1-a)f_I([x],[y])\]</span> <span class="math display">\[f_I(x,[y]+ 1)=af_I([x] + 1,[y] + 1)+(1-a)f_I([x],[y] + 1)\]</span></p><p>得： <span class="math display">\[f_I(x,y)=bf_I(x,[y] +1)+(1-b)f_I(x,[y])\]</span></p><p>这样对于非整数坐标处的函数值，就可以利用它的邻域的四个整数坐标处的函数值进行插值计算而得到。当然，如果先进行两次垂直方向上的插值，然后再进行水平方向上的插值，得到的结果是一样的。</p><h3 id="仿射python-api">2.3 仿射python-API</h3><p>OpenCV 提供了函数： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON">cv2.warpAffine(src, M, dsize[, dst[, flags[, borderMode[, borderValue ]]]])<br></code></pre></td></tr></table></figure> 来实现图像的仿射变换。 src输入图像矩阵</p><p>M 2 行3 列的仿射变换矩阵</p><p>dsize 二元元组(宽, 高)，输出图像的大小</p><p>flags 插值法：INTE_NEAREST、INTE_LINEAR（默认）等</p><p>borderMode 填充模式：BORDER_CONSTANT 等</p><p>borderValue 当borderMode=BORDER_CONSTANT 时的填充值</p><p>示例demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> math<br><span class="hljs-comment">#主函数</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv)&gt;<span class="hljs-number">1</span>:<br>        image = cv2.imread(sys.argv[<span class="hljs-number">1</span>],cv2.CV_LOAD_IMAGE_GRAYSCALE)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Usage: python warpAffine.py image&quot;</span><br>        cv2.imwrite(<span class="hljs-string">&quot;img.jpg&quot;</span>,image)<br>        <span class="hljs-comment">#原图的高、宽</span><br>        h,w=image.shape[:<span class="hljs-number">2</span>]<br>        <span class="hljs-comment">#仿射变换矩阵，缩小2倍</span><br>        A1 = np.array([[<span class="hljs-number">0.5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0</span>]],np.float32)<br>        d1 = cv2.warpAffine(image,A1,(w,h),borderValue=<span class="hljs-number">125</span>)<br>        <span class="hljs-comment">#先缩小2倍，再平移</span><br>        A2 = np.array([[<span class="hljs-number">0.5</span>,<span class="hljs-number">0</span>,w/<span class="hljs-number">4</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>,h/<span class="hljs-number">4</span>]],np.float32)<br>        d2 = cv2.warpAffine(image,A2,(w,h),borderValue=<span class="hljs-number">125</span>)<br>        <span class="hljs-comment">#在d2 的基础上，绕图像的中心点旋转</span><br>        A3 = cv2.getRotationMatrix2D((w/<span class="hljs-number">2.0</span>,h/<span class="hljs-number">2.0</span>),<span class="hljs-number">30</span>,<span class="hljs-number">1</span>)<br>        d3 = cv2.warpAffine(d2,A3,(w,h),borderValue=<span class="hljs-number">125</span>)<br>    cv2.imshow(<span class="hljs-string">&quot;image&quot;</span>,image)<br>        cv2.imshow(<span class="hljs-string">&quot;d1&quot;</span>,d1)<br>        cv2.imshow(<span class="hljs-string">&quot;d2&quot;</span>,d2)<br>        cv2.imshow(<span class="hljs-string">&quot;d3&quot;</span>,d3)<br>        cv2.waitKey(<span class="hljs-number">0</span>)<br>        cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><p>在OpenCV 3.X 中通过定义函数： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(InputArray src, OutputArray dst, <span class="hljs-type">int</span> rotateCode)</span><br></code></pre></td></tr></table></figure>来完成图像矩阵顺时针旋转90∘、180∘、270∘</p><p>src 输入矩阵（单、多通道矩阵都可以）</p><p>dst 输入矩阵</p><p>rotateCode:</p><p>ROTATE_90_CLOCKWISE：顺时针旋转90∘</p><p>ROTATE_180：顺时针旋转180∘</p><p>ROTATE_90_COUNTERCLOCKWISE：顺时针旋转270∘</p><h2 id="三.-投影变换">三. 投影变换</h2><p>类似于仿射变换，OpenCV 提供了函数： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON">cv2.warpPerspective(src,M,dsize[,dst[,flags[,borderMode[,borderValue]]]])<br></code></pre></td></tr></table></figure> 同理<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-comment">#计算投影变换矩阵</span><br>p=cv2.getPerspectiveTransform(src,dst)<br><span class="hljs-comment">#利用计算出的投影变换矩阵进行头像的投影变换</span><br>r = cv2.warpPerspective(image,p,(w,h),borderValue=<span class="hljs-number">125</span>)<br></code></pre></td></tr></table></figure></p><h2 id="四.-极坐标变换">四. 极坐标变换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON">x=np.array([[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]],np.float64)-<span class="hljs-number">1</span><br>y=np.array([[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]],np.float64)-<span class="hljs-number">1</span><br>r,theta = cv2.cartToPolar(x,y,angleInDegrees=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>x array 数组且数据类型为浮点型、float32 或者float64</p><p>y 和x 具有相同尺寸和数据类型的array 数组</p><p>angleInDegrees 当值为True 时，返回值angle 是角度；反之，为弧度</p><p>在以上代码中，将9 个点的横坐标和纵坐标分别对应地放到3 × 3 的ndarray中，当然也可以都放到9 × 1 的ndarray 中，只要x 和y 对应就可以。</p><p>同理</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">x,y=cv2.polarToCart(r,<span class="hljs-built_in">angle</span>,angleInDegrees=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>线性极坐标函数 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dst</span> = cv2.linearPolar(src,center=(<span class="hljs-number">508</span>,<span class="hljs-number">503</span>),maxRadius=<span class="hljs-number">550</span>,cv2.INTER_LINEAR)<br></code></pre></td></tr></table></figure></p><p>src 输入图像矩阵（单、多通道矩阵都可以）</p><p>dst 输出图像矩阵，其尺寸和src 是相同的</p><p>center 极坐标变换中心</p><p>maxRadius 极坐标变换的最大距离</p><p>flags 插值算法，同函数resize、warpAffine 的插值算法</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论最短路径算法</title>
    <link href="/2024/03/10/dijkstra/"/>
    <url>/2024/03/10/dijkstra/</url>
    
    <content type="html"><![CDATA[<p>图是一个特殊的数据结构，有向图和无向图通常都由边与节点构成。很多实际问题都可以抽象成图来解决，如果在一个有边权的图中给定两个点<span class="math inline">\(start\)</span> 和 <spanclass="math inline">\(end\)</span>，在所有 <spanclass="math inline">\(start\)</span> 连接 <spanclass="math inline">\(end\)</span>的路径中寻找边权值和最小的就是最短路径问题。</p><h2 id="floyd-warshall-算法">Floyd-Warshall 算法</h2><p>Floyd 针对的是多源最短路径（一次性求所有节点之间的最短路径）基于 dp的思想：求两点 <span class="math inline">\(i\)</span>， <spanclass="math inline">\(j\)</span>之间的最短距离，分为两种情况考虑，即经过途中某个点 <spanclass="math inline">\(k\)</span> 的路径和不经过 <spanclass="math inline">\(k\)</span> 的路径，再取二者中的更短路径。<spanclass="math inline">\(graph[i][j]\)</span> 表示了 <spanclass="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span>目前已知最短距离，如果要更新，则必定经过第三个点 <spanclass="math inline">\(k\)</span> 中转 <span class="math inline">\(i-&gt; k -&gt; j\)</span>才有可能使路径更短，最外层循环遍历每一个中转节点。</p><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> NUM = <span class="hljs-number">5</span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(NUM, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(NUM, INT_MAX)); <span class="hljs-comment">// 邻接矩阵存图 NUM * NUM</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                graph[i][j] = <span class="hljs-built_in">min</span>(graph[i][j], graph[i][k] + graph[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        graph[u][v] = w;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        graph[i][i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">floyd</span>();<br>    cout &lt;&lt; graph[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>二维 <span class="math inline">\(vector\)</span>用来存储邻接矩阵，并将 <span class="math inline">\(u\)</span> 到 <spanclass="math inline">\(v\)</span>的距离设置为无穷大，节点到自身距离为0，最后输出 1 到 3 的最短路径。</p><p>Floyd算法局限性：可以处理带有负边权的图，但不能含有负环。</p><p>我们可以输入以下的有向图：</p><p><a href=""></a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">4 8 <br>1 2 2<br>2 3 3<br>1 3 6<br>3 1 7<br>4 3 12<br>1 4 4<br>3 4 1<br>1 4 4<br></code></pre></td></tr></table></figure><p>输出结果：5</p><p>时间复杂度：$ O(n^3) $</p><p>空间复杂度：$ O(n^2) $ ， <span class="math inline">\(n\)</span>为问题规模即节点个数。</p><h2 id="dijkstra-算法">Dijkstra 算法</h2><p>这是一个单源最短路径算法，需要用户给定起始点 <spanclass="math inline">\(st\)</span>，用 <spanclass="math inline">\(dis[i]\)</span> 数组记录 <spanclass="math inline">\(st\)</span> 到 <spanclass="math inline">\(i\)</span> 的最短路径。</p><p>Dijkstra 思想是维护两个点的集合 <spanclass="math inline">\(A\)</span>（称为白点，已确定最短路径）与 <spanclass="math inline">\(B\)</span>（称为蓝点，未确定最短路径），集合 <spanclass="math inline">\(A\)</span> 向外扩散至邻居节点 <spanclass="math inline">\(B\)</span>，从而完成最短路计算。伪代码如下：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata">create the <span class="hljs-keyword">graph</span>;<br>vectorA push_back start;<br>vectorB push_back allNeighbors of A;<br><span class="hljs-keyword">u</span> = minOfDistanceFromStart;<br>vectorA push_back <span class="hljs-keyword">u</span>;<br><br>v = oneOfuNeighbors;<br><span class="hljs-keyword">dis</span>[s,v] = <span class="hljs-keyword">dis</span>[s,<span class="hljs-keyword">u</span>] + <span class="hljs-keyword">dis</span>[<span class="hljs-keyword">u</span>,v];<br><br>redo<br></code></pre></td></tr></table></figure><p>朴素算法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> NUM = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> next, w8;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> w): <span class="hljs-built_in">next</span>(n), <span class="hljs-built_in">w8</span>(w) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(NUM, INT_MAX)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start, vector&lt;vector&lt;node&gt;&gt; &amp;g, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <br>    dis[start] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 每次大循环至少会更新一个点到 vis 数组中，最坏情况会执行 n 次确定所有点的最短路径（也可能会提前结束）</span><br>        <span class="hljs-type">int</span> min_pos = <span class="hljs-number">0</span>, min_cur = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; min_cur) &#123;<br>                min_pos = j;<br>                min_cur = dis[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!min_pos) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 一轮未标记，结束循环</span><br>        vis[min_pos] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;neighbor : g[min_pos]) &#123; <span class="hljs-comment">// 更新 min_pos 的邻居节点</span><br>            <span class="hljs-type">int</span> v = neighbor.next, w = neighbor.w8;<br>            dis[v] = <span class="hljs-built_in">min</span>(dis[v], dis[min_pos] + w);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;node&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;node&gt;()); <span class="hljs-comment">// 邻接表存图</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        graph[u].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">node</span>(v, w));<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>, graph, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : dis) &#123;<br>        cout &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">// 打印 1 到其他每个节点的最短路径</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度： $ O(n^2) $</p><p>空间复杂度： $ O(m + n) $</p><p>基于堆的优化版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> NUM = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> next, w8;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> w): <span class="hljs-built_in">next</span>(n), <span class="hljs-built_in">w8</span>(w) &#123;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node &amp;other) <span class="hljs-type">const</span> &#123; <span class="hljs-comment">// 操作符重载 用于堆排列</span><br>        <span class="hljs-keyword">return</span> w8&gt; other.w8;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(NUM, INT_MAX)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start, vector&lt;vector&lt;node&gt;&gt; &amp;g, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    dis[start] = <span class="hljs-number">0</span>;<br>    <br>    priority_queue&lt;node&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(start, <span class="hljs-number">0</span>));<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> cur = q.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 每次会取出邻居节点中最大的</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;neighbor : g[cur.next]) &#123;<br>            <span class="hljs-keyword">if</span> (dis[cur.next] + neighbor.w8 &lt; dis[neighbor.next]) &#123;<br>                dis[neighbor.next] = dis[cur.next] + neighbor.w8;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(neighbor.next, neighbor.w8));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m; <span class="hljs-comment">// 点 n 边 m</span><br>    vector&lt;vector&lt;node&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;node&gt;()); <span class="hljs-comment">// 邻接表存图</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        graph[u].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">node</span>(v, w));<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>, graph, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : dis) &#123;<br>        cout &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">// 打印 1 到其他每个节点的最短路径</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度： $ O((m + n)log n) $</p><p>$ nlogn $来自于每个节点都可能入队列（使用优先队列，每次插入的复杂度为 $ logn$）。</p><p>$ mlogn $ 来自于每条边都可能导致一个新的节点入队列。</p><p>因此，总的时间复杂度为 $ O((m+n)logn) $。</p><p>空间复杂度： $ O(m + n) $</p><h2 id="bellman-ford-算法-解决负边权">Bellman-Ford 算法 ————解决负边权</h2><p>与 Floyd 算法有相似之处，Floyd遍历了所有的节点 <spanclass="math inline">\(k\)</span>，<span class="math inline">\(k\)</span>作为中转判断是否使 <span class="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span> 的路径更短。</p><p>Bellman 算法核心是遍历所有的边 <spanclass="math inline">\(j\)</span>，根据 <span class="math inline">\(u-&gt; j -&gt; v\)</span> 更新 <span class="math inline">\(v\)</span>的最短路径。</p><p>每次循环中，遍历所有的边 int j = 1; j &lt;= m，如果 dis[u] + j.w8&lt; dis[v]，更新 dis[v] = dis[u] +j.w8，这一次循环被称为一次松弛（relax）。</p><p>那么需要多少次循环呢？</p><p>最多 <span class="math inline">\(n - 1\)</span>次，因为一条最短路径的长度最多为 $ n - 1 $ 条边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> NUM = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> from, to, w8;<br>    <span class="hljs-built_in">edge</span>(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> w):<span class="hljs-built_in">from</span>(from), <span class="hljs-built_in">to</span>(to), <span class="hljs-built_in">w8</span>(w) &#123;&#125;<br>&#125;;<br><br>vector&lt;edge&gt; e; <span class="hljs-comment">// 用所有边来存图</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(NUM, INT_MAX / <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(NUM)</span></span>; <span class="hljs-comment">// 前驱:pre[x] = y，表示 x 的前一个点是 y</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    dis[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 起点距离为 0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123; <span class="hljs-comment">// 遍历边</span><br>            <span class="hljs-type">int</span> x = e[j].from, y = e[j].to;<br>            <span class="hljs-keyword">if</span> (dis[y] &gt; dis[x] + e[j].w8) &#123;<br>                dis[y] = dis[x] + e[j].w8;<br>                pre[y] = x;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m; <span class="hljs-comment">// 点 n 边 m</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> x, y, weight;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; weight;<br>        e.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(x, y, weight));<br>    &#125;<br>    <span class="hljs-built_in">bellman</span>(<span class="hljs-number">1</span>, n, m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ;i++) &#123;<br>        cout &lt;&lt; dis[i] &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度： $ O(mn) $</p><p>空间复杂度： $ O(m + n) $</p><h2 id="spfa-队列优化的-bellman">SPFA* ———— 队列优化的 Bellman</h2><p>SPFA（Shortest Path FasterAlgorithm）算法是一种用于求解图中最短路径问题的算法，它是 Bellman-Ford算法的队列实现（不是优先队列）。SPFA算法使用了类似广度优先搜索（BFS）的策略，但它并不是纯粹的广度优先搜索。</p><p>在 SPFA算法中，我们使用一个队列来保存所有待处理的节点。初始时，我们将起点加入队列。然后，我们不断从队列中取出节点，对其进行松弛操作，并将所有从这个节点出发可以到达的、并且可以通过松弛操作更新距离的节点加入队列。这个过程一直持续到队列为空，也就是没有节点需要处理为止。</p><p>因此，你可以看到，SPFA算法中的这个过程和广度优先搜索有一些相似之处，但它们并不完全相同。在广度优先搜索中，我们只会访问每个节点一次，而在SPFA算法中，一个节点可能会被加入队列多次，每次当我们通过松弛操作更新了这个节点的距离时，就会将这个节点再次加入队列。</p><p>（1）起点s入队，计算它所有邻居到s的最短距离(当前最短距离，可能不是全局最短，把计算一个结点到起点s的最短路径简称为更新状态，最后的“状态”就是SPFA的计算结果)。把s出队，状态有更新的邻居入队，没更新的不入队。即，队列中都是状态有变化的结点，只有这些结点才会影响最短路径的计算。</p><p>（2）现在队列的头部是s的一个邻居u。弹出u，更新其所有邻居的状态，把其中有状态变化的邻居入队。</p><p>（3）这里有一个问题，弹出u之后，在后面的计算中u可能会再次更新状态(u借道其他结点去s的路径更短)。所以，u可能需要重新入队。</p><p>（4）继续以上过程，直到队列为空。这也意味着所有结点的状态不再更新，最后的状态就是到起点s的最短路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> from, to, w8;<br>    <span class="hljs-built_in">edge</span>(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> w):<span class="hljs-built_in">from</span>(from), <span class="hljs-built_in">to</span>(to), <span class="hljs-built_in">w8</span>(w) &#123;&#125;<br>&#125;;<br><br>vector&lt;vector&lt;edge&gt;&gt; e; <span class="hljs-comment">// 邻接表</span><br>vector&lt;<span class="hljs-type">int</span>&gt; dis;<br>vector&lt;<span class="hljs-type">int</span>&gt; pre; <span class="hljs-comment">// 前驱:pre[x] = y，表示 x 的前一个点是 y</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SPFA</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(e.size(), <span class="hljs-number">0</span>)</span></span>;<br><br>    dis[start] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    vis[start] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> cur = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        vis[cur] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; e[cur].<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> u = e[cur][i].to, w8 = e[cur][i].w8;<br>            <span class="hljs-keyword">if</span> (dis[cur] + w8 &lt; dis[u]) &#123;<br>                dis[u] = dis[cur] + w8;<br>                pre[u] = cur;<br>                <span class="hljs-keyword">if</span> (!vis[u]) &#123;<br>                    vis[u] = <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(u);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;spfa.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m; <span class="hljs-comment">// 点 n 边 m</span><br>    e.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>    dis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, INT_MAX / <span class="hljs-number">2</span>);<br>    pre.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> x, y, weight;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; weight;<br>        e[x].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(x, y, weight));<br>    &#125;<br>    <span class="hljs-built_in">SPFA</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ;i++) &#123;<br>        cout &lt;&lt; dis[i] &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度： $ O(mn) $</p><p>空间复杂度： $ O(n + m) $</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVL平衡二叉树</title>
    <link href="/2024/01/13/AVLTree/"/>
    <url>/2024/01/13/AVLTree/</url>
    
    <content type="html"><![CDATA[<h2 id="一.知识基础">一.知识基础</h2><p>1.二叉树的建立，遍历</p><p>2.二叉搜索树的构建，遍历，查找和删除节点。</p><h2 id="二.avl平衡树">二.AVL平衡树</h2><p>BST: 10 -&gt; 20 -&gt; 30 -&gt; 40 -&gt; 50</p><p>AVL: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">   <span class="hljs-number">20</span><br> /    \<br><span class="hljs-number">10</span>    <span class="hljs-number">40</span><br>     /  \ <br>   <span class="hljs-number">30</span>    <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure></p><p>当生成二叉树时，如果是有序序列（递增或递减）实际上是一只链表，AVL平衡二叉树用于提高二叉树的查找效率。</p><p>10左子树树高：0</p><p>右子树树高：4</p><p>如图，对每个节点进行相同的操作:</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/AVL%E6%88%AA%E5%B1%8F2024-01-13%2021.23.55.png" /></p><p>目标：使每个节点的左右树高绝对差值尽可能小，我们可引出概念：</p><p>平衡因子：左子树-右子树高度（平衡因子绝对值&lt;=1）</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/AVL%E6%88%AA%E5%B1%8F2024-01-13%2021.25.08.png" /></p><p>如果平衡因子绝对值 &gt; 1，怎么办呢：</p><p>a.左旋</p><p>step1.当前节点的右子树作为新树的根节点</p><p>step2.当前节点作为根节点左节点</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/AVL%E6%88%AA%E5%B1%8F2024-01-13%2021.29.25.png" /></p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/AVL%E6%88%AA%E5%B1%8F2024-01-13%2021.31.11.png" /></p><p>满足旋转后满足：1.是BST 2.每个平衡因子&lt;=1</p><p>b.右旋</p><p>c.二叉树的失衡</p><p>什么时候会遇到失衡？</p><p>1.插入节点时</p><p>(1)root left插入左子树left(LL失衡)</p><p>应用一次右旋</p><p>(2)LR失衡</p><p>root left 左旋，转化为递减搜索树，再将 root 右旋即可。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/AVL%E6%88%AA%E5%B1%8F2024-01-13%2021.46.09.png" /></p><p>(3)RR失衡:root左旋</p><p>(4)RL失衡：</p><p>root right 右旋 ，转化为递增搜索树，再将 root 左旋即可。</p><p>以下是完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//定义旋转操作</span><br><span class="hljs-function">TreeNode* <span class="hljs-title">leftRotate</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>  TreeNode* newRoot = root-&gt;right;<br>  TreeNode* buff = newRoot-&gt;left;<br>  newRoot-&gt;left = root;<br>  root-&gt;right = buff;<br><br>  root-&gt;height = <span class="hljs-built_in">getHeight</span>(root);<br>  newRoot-&gt;height = <span class="hljs-built_in">getHeight</span>(newRoot);<br><br>  <span class="hljs-keyword">return</span> newRoot;<br>&#125;<br><span class="hljs-function">TreeNode* <span class="hljs-title">rightRotate</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>  TreeNode* newRoot = root-&gt;left;<br>  TreeNode* buff = newRoot-&gt;right;<br>  newRoot-&gt;right = root;<br>  root-&gt;left = buff;<br><br>  root-&gt;height = <span class="hljs-built_in">getHeight</span>(root);<br>  newRoot-&gt;height = <span class="hljs-built_in">getHeight</span>(newRoot);<br><br>  <span class="hljs-keyword">return</span> newRoot;<br>&#125;<br><br><span class="hljs-comment">// 二叉搜索树插入</span><br><span class="hljs-comment">/* void BSTInsert(TreeNode* &amp;T, int data) &#123; */</span><br><span class="hljs-comment">/*   if (T == nullptr) &#123; */</span><br><span class="hljs-comment">/*     T = new TreeNode(data); */</span><br><span class="hljs-comment">/*   &#125; else &#123; */</span><br><span class="hljs-comment">/*     if (data &gt; T-&gt;value) &#123; */</span><br><span class="hljs-comment">/*       BSTInsert(T-&gt;right, data); */</span><br><span class="hljs-comment">/*     &#125; else &#123; */</span><br><span class="hljs-comment">/*       BSTInsert(T-&gt;left, data); */</span><br><span class="hljs-comment">/*     &#125; */</span><br><span class="hljs-comment">/*   &#125; */</span><br><span class="hljs-comment">/*   T-&gt;height = getHeight(T); */</span><br><span class="hljs-comment">/*   // AVL平衡二叉树旋转 */</span><br><span class="hljs-comment">/**/</span><br><span class="hljs-comment">/*   if (getBalance(T) &gt; 1 &amp;&amp; getBalance(T-&gt;left) &gt; 0) &#123; */</span><br><span class="hljs-comment">/**/</span><br><span class="hljs-comment">/*   &#125; */</span><br><span class="hljs-comment">/* &#125; */</span><br><br><span class="hljs-function">TreeNode* <span class="hljs-title">BSTInsert</span><span class="hljs-params">(TreeNode* node, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(value);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (value &gt; node-&gt;value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">BSTInsert</span>(node-&gt;right, value);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; node-&gt;value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">BSTInsert</span>(node-&gt;left,value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//value == node-&gt;value</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;invalid&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> node;<span class="hljs-comment">//易错：返回空指针</span><br>  &#125;<br>  node-&gt;height = <span class="hljs-built_in">getHeight</span>(node);<br>  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getBalance</span>(node) &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(node-&gt;left) &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(node);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getBalance</span>(node) &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(node-&gt;left) &lt; <span class="hljs-number">0</span>) &#123;<br>    node-&gt;left = <span class="hljs-built_in">leftRotate</span>(node-&gt;left);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(node);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getBalance</span>(node) &lt; <span class="hljs-number">-1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(node-&gt;right) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(node);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getBalance</span>(node) &lt; <span class="hljs-number">-1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(node-&gt;right) &gt; <span class="hljs-number">0</span>) &#123;<br>    node-&gt;right = <span class="hljs-built_in">rightRotate</span>(node-&gt;right);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(node);<br>  &#125;<br>  <span class="hljs-keyword">return</span> node;<span class="hljs-comment">//注意！！！</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>2.删除节点时</p><p>删除节点导致二叉树失衡也分为四种情况：LL LR RR RL</p><p>但要注意特殊情况，如下图所示，当删除了root的右子树，左子树的平衡因子=0，此时仍为LL失衡：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/AVL%E6%88%AA%E5%B1%8F2024-01-14%2016.17.56.png" /></p><p>只需要给LL和RR加上等于号即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 二叉搜索树删除节点</span><br><span class="hljs-function">TreeNode *<span class="hljs-title">BSTDelete</span><span class="hljs-params">(TreeNode *node, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 空指针处理</span><br><br>  <span class="hljs-keyword">if</span> (node-&gt;value &gt; val) &#123;<br>    node-&gt;left = <span class="hljs-built_in">BSTDelete</span>(node-&gt;left, val); <span class="hljs-comment">// 节点的左子树有目标删除节点</span><br>    <span class="hljs-keyword">return</span> node;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (node-&gt;value &lt; val) &#123; <span class="hljs-comment">// 节点的右子树有目标删除节点</span><br>    node-&gt;right = <span class="hljs-built_in">BSTDelete</span>(node-&gt;right, val);<br>    <span class="hljs-keyword">return</span> node;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (node-&gt;value == val) &#123; <span class="hljs-comment">// 找到删除节点，分为四种情况1.没有左右子树</span><br><br>    <span class="hljs-keyword">if</span> (node-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">delete</span> node;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>      TreeNode *temp = node-&gt;left; <span class="hljs-comment">// 临时保存T</span><br>      <span class="hljs-keyword">delete</span> node;<br>      <span class="hljs-keyword">return</span> temp;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>      TreeNode *temp = node-&gt;right; <span class="hljs-comment">// 临时保存T</span><br>      <span class="hljs-keyword">delete</span> node;<br>      <span class="hljs-keyword">return</span> temp;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 左右都有，两种解决方案</span><br>      <span class="hljs-comment">// solution1.右子树加到左子树</span><br>      TreeNode *cur = node-&gt;left;<br>      <span class="hljs-keyword">while</span> (cur-&gt;right != <span class="hljs-literal">nullptr</span>)<br>        cur = cur-&gt;right;<br>      cur-&gt;right = node-&gt;right;<br>      TreeNode *temp = node-&gt;left;<br>      <span class="hljs-keyword">delete</span> node;<br>      <span class="hljs-keyword">return</span> temp;<br><br>      <span class="hljs-comment">// solution2.左子树加到右子树</span><br>      <span class="hljs-comment">/* TreeNode* cur = T-&gt;right; */</span><br>      <span class="hljs-comment">/* while(cur-&gt;left!= nullptr) cur = cur-&gt;left; */</span><br>      <span class="hljs-comment">/* cur-&gt;left = T-&gt;left; */</span><br>      <span class="hljs-comment">/* TreeNode* temp = T-&gt;right; */</span><br>      <span class="hljs-comment">/* delete T; */</span><br>      <span class="hljs-comment">/* return temp; */</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">// 删除完成下面开始调整</span><br>  <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span> node;<br>  &#125;<br>  <span class="hljs-comment">// 更新树高</span><br>  node-&gt;height = <span class="hljs-built_in">getHeight</span>(node);<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getBalance</span>(node) &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(node-&gt;left) &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(node);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getBalance</span>(node) &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(node-&gt;left) &lt; <span class="hljs-number">0</span>) &#123;<br>    node-&gt;left = <span class="hljs-built_in">leftRotate</span>(node-&gt;left);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(node);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getBalance</span>(node) &lt; <span class="hljs-number">-1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(node-&gt;right) &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(node);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getBalance</span>(node) &lt; <span class="hljs-number">-1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(node-&gt;right) &gt; <span class="hljs-number">0</span>) &#123;<br>    node-&gt;right = <span class="hljs-built_in">rightRotate</span>(node-&gt;right);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(node);<br>  &#125;<br>  <span class="hljs-keyword">return</span> node;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>旋转矩阵解算欧拉角</title>
    <link href="/2023/12/20/matrixEular/"/>
    <url>/2023/12/20/matrixEular/</url>
    
    <content type="html"><![CDATA[<h2 id="一.旋转矩阵">一.旋转矩阵</h2><center><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-38f253e4128e2809f85fb42121f5eff2_720w.webp" /></p><p><span class="math inline">\(x&#39;=|OP|\,cos(\alpha +\beta)=|OP|(cos\alpha cos\beta - sin\alphasin\beta)=xcos\beta-ysin\beta\)</span></p><span class="math inline">\(y&#39;=|OP|sin(\alpha + \beta) =|OP|(sin\alpha cos\beta+cos\alpha sin\beta) =ycos\beta+xsin\beta\)</span></center>改写矩阵形式：<center><p><spanclass="math inline">\(\begin{bmatrix}x&#39;\\y&#39;\end{bmatrix} =\begin{bmatrix}cos\beta\,-sin\beta\\sin\beta\,\,\,\,\,cos\beta\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}\)</span></p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-0a18ca4a6a06fa2da2e68010d57adc54_720w.webp" /></p><p><spanclass="math inline">\(\begin{bmatrix}x&#39;\\y&#39;\\z&#39;\end{bmatrix}=\begin{bmatrix}cos\beta\,-sin\beta\,\,0\\sin\beta\,\,\,\,\,cos\beta\,\,\,\,\,0\\\,\,\,\,\,0\,\,\,\,\,\,\,\,\,\,\,\,0\,\,\,\,\,\,\,\,\,\,\,1\end{bmatrix}\begin{bmatrix}x\\y\\z\end{bmatrix}\)</span></p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-da669f4d1d9f5852bc926a185254b5d3_720w.webp" /></p><p><spanclass="math inline">\(\begin{bmatrix}x&#39;\\y&#39;\\z&#39;\end{bmatrix}=\begin{bmatrix}cos\beta\,0\,\,sin\beta\\0\,\,\,\,\,1\,\,\,\,\,0\\\,\,\,\,\,-sin\beta\,\,\,\,\,\,\,\,\,\,\,\,0\,\,\,\,\,\,\,\,\,\,\,cos\beta\end{bmatrix}\begin{bmatrix}x\\y\\z\end{bmatrix}\)</span>（y有点不同）</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-fbee9db2b50dd93f3fa4576b3062791d_720w.webp" /></p><spanclass="math inline">\(\begin{bmatrix}x&#39;\\y&#39;\\z&#39;\end{bmatrix}=\begin{bmatrix}1\,0\,\,0\\0\,\,\,\,\,cos\beta\,\,\,\,\,-sin\beta\\\,\,\,\,\,0\,\,\,\,\,\,\,\,\,\,\,\,sin\beta\,\,\,\,\,\,\,\,\,\,\,cos\beta\end{bmatrix}\begin{bmatrix}x\\y\\z\end{bmatrix}\)</span></center><p>旋转矩阵<span class="math inline">\(A\)</span>与逆矩阵<spanclass="math inline">\(A^{-1}\)</span>角度相同，旋转方向相反。</p><p>坐标系旋转与向量旋转互为逆过程<strong>坐标系旋转</strong>的旋转矩阵与上面<strong>向量旋转</strong>的旋转矩阵正好是<strong>转置的关系</strong>(实际上是<strong>逆矩阵</strong>，因为正交阵的逆矩阵与转置矩阵相同)，因为这两种旋转本质上是相对运动，互为逆过程。</p><h2 id="二.欧拉角旋转">二.欧拉角旋转</h2><h3 id="静态定义">静态定义</h3><p>对于在三维空间里的一个<strong>参考系</strong>，任何<strong>坐标系</strong>的取向，都可以用三个欧拉角来表现。</p><ul><li><p><strong>参考系</strong>又称为实验室参考系，是静止不动的，可以先简单的理解理解为<strong>大地坐标系</strong>，也称<strong>惯性坐标系</strong>。</p></li><li><p><strong>坐标系</strong>则固定于刚体，随著刚体的旋转而旋转，比如<strong>飞行器自身的坐标系</strong>，也称<strong>载体坐标系</strong>。</p><center><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-5542d4a1edb53d1ec8ae39e99926bacc_720w.webp" /></p></center></li></ul><p>如上图为一种<strong>ZYZ顺序旋转</strong>的欧拉角示意图：</p><ul><li><p>设蓝色的<strong>xyz-轴</strong>为惯性系的参考轴，即大地坐标系的3个轴。</p></li><li><p>设红色的<strong>XYZ-轴</strong>为载体系的参考轴，即飞行器坐标系的3个轴。</p></li><li><p>称<strong>xy-平面</strong>与<strong>XY-平面</strong>的相交为<strong>交点线</strong>，用英文<strong>字母N</strong>表示。</p></li></ul><p>图中的角度符号：</p><ul><li><p>α是x-轴与交点线的夹角，载体坐标系先绕Z轴旋转了α角度（范围0~2Pi弧度）。</p></li><li><p>β是z-轴与Z-轴的夹角，载体坐标系又绕当前的Y轴旋转了β角度（范围<strong>0~Pi</strong>弧度）。</p></li><li><p>γ是交点线与X-轴的夹角，载体坐标系又绕当前的Z轴旋转了γ角度（范围0~2Pi弧度）。</p></li><li><p>这里角度的正负是按照<strong>右手定则</strong>，如右手大拇指指向z-轴，四指弯曲的旋转方向为α正方向。</p></li></ul><p>实际上，对于夹角的顺序和标记，夹角的两个轴的指定，并没有明确的规定。因此当用到欧拉角时，需要明确地表示出夹角的顺序，指定其参考轴。合法的欧拉角组中，唯一的限制是，任何两个连续的旋转，必须绕着不同的转动轴旋转。因此，一共有12种表示。</p><ul><li><p>6种绕三条轴的旋转（<strong>Tait-Bryan Angle</strong>）：XYZ, XZY,YXZ, YZX, ZXY, <strong>ZYX</strong></p></li><li><p>6种只绕两条轴的旋转（<strong>Proper Euler Angle</strong>）：XYX,YXY, XZX, ZXZ, YZY, ZYZ</p></li></ul><h3 id="动态定义">动态定义</h3><p>我们也可以给予欧拉角两种不同的动态定义。一种是绕<strong>固定于载体的坐标轴</strong>的三个旋转的复合；另外一种是绕<strong>大地坐标系参考轴</strong>的三个旋转的复合。</p><p>用动态的定义，我们能更了解，欧拉角在物理上的含义与应用。</p><p>注意，以下的描述,<strong>大写字母XYZ坐标轴</strong>是旋转的载体坐标轴；<strong>小写字母xyz坐标轴</strong>是静止不动的大地参考轴。</p><p>现在以<strong>旋转顺序</strong>依次是<strong>Z、Y、X</strong>的方式来描述欧拉角的两种动态定义。</p><ul><li><p><strong>定义A：绕着XYZ坐标轴旋转</strong>（载体坐标轴）：</p></li><li><p>最初，两个坐标系统xyz与XYZ的坐标轴都是重叠的。</p></li><li><p>开始，绕着Z-轴旋转α角度。</p></li><li><p>然后，绕着Y-轴旋转β角度。</p></li><li><p>最后，绕着X-轴旋转γ角度。</p></li></ul><p>设任何一点P1在xyz与XYZ坐标系统的坐标分别为r1与R1。定义Z(α)为绕着Z-轴旋转α角度，Y(β)为绕着Y-轴旋转β角度，X(γ)为绕着X-轴旋转γ角度。则定义A可以表述如下：</p><center><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-45983061372651d5806873334cdbaa8b_720w.webp" /></center><p>注意这里又有<strong>矩阵左乘与右乘</strong>的概念，绕载体坐标系旋转是<strong>矩阵依次左乘</strong>，即<strong>X&lt;- Y &lt;- Z</strong>。</p><ul><li><p><strong>定义B：绕着xyz坐标轴旋转</strong>（大地坐标轴）：</p></li><li><p>最初，两个坐标系统xyz与XYZ的坐标轴都是重叠的。</p></li><li><p>开始，绕着z-轴旋转α角度。</p></li><li><p>然后，绕着y-轴旋转β角度。</p></li><li><p>最后，绕着x-轴旋转γ角度。</p></li></ul><p>设任何一点P2在xyz与XYZ坐标系统的坐标分别为r2与R2。定义z(α)为绕着z-轴旋转α角度，y(β)为绕着y-轴旋转β角度，x(γ)为绕着x-轴旋转γ角度。则定义B可以表述如下：</p><center><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-bd3cd2568708713e3c1c8a35a58664fb_720w.webp" /></center><p>注意绕大地坐标系旋转是<strong>矩阵依次右乘</strong>，即<strong>z-&gt; y -&gt; x</strong>。</p><p>定义A与静态定义的相等，这可以直接用几何制图方法来核对。</p><p><strong>定义A与定义B的相等</strong>可以用旋转矩阵来证明：</p><center><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-bc2da96876f5527ffca48120c9561f77_720w.webp" /></center><h2 id="三.加速度计解算">三.加速度计解算</h2><p>姿态的旋转选用ZYX顺序的3次旋转方式，则上述描述可表示为：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-3dc75acdc5b5e64f2af9b3fb28b368de_720w.webp" /></p><center><p><spanclass="math inline">\(a_x=-g\,sin\,pitch(1)\\a_y=cos\,pitch\,sin\,roll\,g(2)\\a_z=cos\,pitch\,cos\,roll\,g(3)\)</span></p><p>(2)/(3)： <span class="math inline">\(\frac{a_y}{a_z}=tan\,roll=&gt;roll = arctan\frac{a_y}{a_z}\)</span></p><p><span class="math inline">\(\sqrt{(2)^2+(3)^2}：\)</span> <spanclass="math inline">\(\sqrt{a_y^2 + a_z^2}=cospitch \,g(4)\)</span></p>（1）/（4）： <span class="math inline">\(pitch =-arctan\frac{a_x}{\sqrt{a_y^2+a_z^2}}\)</span></center><p>解这个方程，可以得到roll和pitch角（由于绕Z旋转时，感受到的重力加速度是不变的，因此加速度计无法计算yaw角）</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-0c08fbd578d1aa64ea64c617c6eac39a_720w.webp" /></p><p>3次旋转过程的分解过程如下图：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-4ea6ee4cd2b5e33586959d13a3fef083_720w.webp" /></p><h2 id="四.角速度计解算">四.角速度计解算</h2><p>陀螺仪测量的绕3个轴转动的角速度，因此，对角速度积分，可以得到角度。陀螺仪的英文简写为gyro，下面用<strong>首字母g</strong>代表陀螺仪数据。</p><p>如下图，IMU在第n个时刻的姿态角度为r、p、y，其含义为IMU坐标系从初始位置，经过绕Z旋转y角度，绕Y旋转p角度，绕X旋转r角度，得到了最终的姿态，此时需要计算下一个时刻(n+1)的姿态。设n+1时刻的姿态角为r+Δr、p+Δp、y+Δy，该姿态也是经历了3次旋转。要想计算n+1时刻的姿态，只要在n时刻姿态的基础上，加上对应的姿态角度变化量即可。姿态角度的变化量可以通过角速度与采用时间周期积分即可。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-8ccc744d3fc64f86e3133ac836b2e0cb_720w.webp" /></p><p>这里<strong>红框中dr/dt等角速度</strong>实际是假想的角速度，用于<strong>姿态更新</strong>，姿态更新是以大地坐标系为参考，而陀螺仪在第n个状态读出的角速度是以它自己所在的坐标系为参考，需要将读到的gyro陀螺数据经过变换，才能用于计算更新第n+1次的姿态。</p><p>那dr/dt等角速度该怎样理解呢？看下面这个图，还是将其分解为3次旋转：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-f42b5d1dbdaac7e99cb91f2f9bafbb87_720w.webp" /></p><p><strong>首先来看dy/dt</strong>，它是3次旋转过程中<strong>绕Z轴的yaw角的角速度</strong>，3次旋转首先就是绕着Z轴旋转，Z轴方向的单位向量可表示为[00 1]T，T表示向量转置，因此[0 0dy/dt]T表示在图中状态①的坐标中绕Z的角速度。由于之后该坐标系还要经历<strong>绕Y和绕X的两次旋转</strong>，因此这里[00dy/dt]T角速度在经历两次旋转后，在最终的坐标系(状态③)中的坐标也要经历两次变换。图中的[gx_Zgy_Zgz_Z]T表示3次旋转过程中绕Z轴的yaw角的角速度在最终姿态中的<strong>等效</strong>转动角速度，实际就是状态①坐标系中绕Z轴的角速度在状态③坐标系中的新的坐标。</p><p><strong>同理</strong>，dp/dt还需要经历1次旋转变换，而dr/dt不需要经历旋转。</p><p>将dy/dt，dp/dt，dr/dt三者都变换到状态③坐标系中的新的坐标相加，实际就是状态③时刻陀螺仪自己读到的gyro数据。</p><p><strong>所以</strong>，从dr/dt等角速度到陀螺仪读到的角速度gx等的转换关系推导过程如下：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-b8e2f588258c2297a06bb2dca7381e8f_720w.webp" /></p><p><strong>进一步</strong>，再把这里的状态③理解为状态n，则根据状态n时刻读到的陀螺仪数据，反解dy/dt等角速度数据，即可更新得到状态n+1的姿态。反解就是求逆矩阵，即：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-8f9e706d1378f9aa57b57320c1d48c5d_720w.webp" /></p><h2 id="五.姿态融合">五.姿态融合</h2><p>由上面的分析可知，<strong>加速度计</strong>在静止时刻，根据感受到的重力加速度，可以计算出roll和pitch角，并且角度计算只与当前姿态有关。而<strong>陀螺仪</strong>是对时间间隔内的角速度积分，得到每一次的角度变换量，累加到上一次的姿态角上，得到新的姿态角，陀螺仪可以计算roll、pitch、yaw三个角。</p><p>实际上，加速度仅在静止时刻可以得到较准确的姿态，而陀螺仪仅对转动时的姿态变化敏感，且陀螺仪若本身存在误差，则经过连续的时间积分，误差会不断增大。因此，需要结合两者计算的姿态，进行互补融合。当然，这里只能对roll和pitch融合，因为加速度计没有得到yaw。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/matrixv2-b2bb643d59b3f143b7555074e4d5b3b6_720w.webp" /></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kalman滤波算法</title>
    <link href="/2023/11/27/KalmanFilter/"/>
    <url>/2023/11/27/KalmanFilter/</url>
    
    <content type="html"><![CDATA[<h2 id="一.基础知识">一.基础知识</h2>1.高斯噪声：噪声满足正态分布<br />2.宏观意义：滤波即加权<br />理想状态： 信号x1 + 噪声x0<br />LPF(Low pass filter):低电平x1高电平x0<br />卡尔曼滤波：估计值x（权重） 观测值x（权重） -&gt;修正<br />3.协方差 ：描述两个随机变量的相关性<br /><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/kalmanimage.png"alt="image.png" /><br /><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/kalmanimage%20(1).png"alt="image.png" /><br />坐标原点为平均值<spanclass="math inline">\((\bar{x},\,\bar{y})\)</span>，每个样本点与原点围成的矩形面积之和可以描述相关性（红色为正，蓝色为负）：<br />公式表示为：<br /><center><span class="math inline">\(\sum(x_i - \bar{x})(y_i -\bar{y})\begin{cases} &gt;0，正相关 \\= 0, 不相关 \\&lt;0，负相关\end{cases}\)</span></center>常用加权形式（概率为统计经验）：<br /><center><span class="math inline">\(\sum p_i(x_i - \mu_X)(y_i - \mu_Y)\)</span></center><br /><center><span class="math inline">\(Cov(X, Y) = E[(X-\mu_X)(Y-\mu_Y)]\)</span></center><br />4.协方差矩阵<br />经过去中心化处理后的m个样本点，每个样本包含3个数据<spanclass="math inline">\(a_i\,b_i\,c_i\)</span>，每组样本的数据列向量的形式保存在矩阵X中：<br /><center><span class="math inline">\(X=\begin{bmatrix}a_1\,a_2\,a_3\,......\,a_m\\b_1\,b_2\,b_3\,......\,b_m\\c_1\,c_2\,c_3\,......\,c_m\end{bmatrix}\)</span></center><br /><center><spanclass="math inline">\(P=\frac{1}{m}XX^T=\frac{1}{m}\begin{bmatrix}a_1\,a_2\,......\,a_m\\b_1\,b_2\,......\,b_m\\c_1\,c_2\,......\,c_m\end{bmatrix}\begin{bmatrix}a_1\,b_1\,c_1\\a_2\,b_2\,c_2\\......\\a_m\,b_m\,c_m\end{bmatrix}=\begin{bmatrix}Cov(a,\,a)\,\,\,\,Cov(a,\,b)\,\,\,\,Cov(a,\,c)\\Cov(b,\,a)\,\,\,\,Cov(b,\,b)\,\,\,\,Cov(b,\,c)\\Cov(c,\,a)\,\,\,\,Cov(c,\,b)\,\,\,\,Cov(c,\,c) \end{bmatrix}\)</span></center><p><br />可见，协方差矩阵由方差和协方差组成。</p><h2 id="二.进阶">二.进阶</h2>1.状态空间表达式<br />状态方程<br /><center><span class="math inline">\(x_k = Ax_{k-1} + Bu_k + w_k\)</span></center><br />xk当前状态当前值 x_k-1上个时刻给状态的值 u输入wk过程噪声<br />A状态转移矩阵 B控制矩阵 <br />eg.小车匀速直线运动 <spanclass="math inline">\(x_k = x_{k - 1} + v dt +w_k\)</span><br />观测方程<br /><center><span class="math inline">\(y_k = Cx_k + v_k\)</span></center><br />2.参数分析<br />（1）过程噪声<spanclass="math inline">\(w_k服从N(0, Q_k)\)</span><br /> 观测噪声<spanclass="math inline">\(v_k服从N(0,R_k)\)</span><br />称为高斯白噪声<br /> (2) 方差 一维方差delta二维协方差<br />当前先验估计值 + 观测值 ————&gt; 当前最优估计值<br />3.预测阶段<br />预测t时刻先验估计：<br /><center><span class="math inline">\(\hat{x_t^-}=F\hat{x}_{t-1}+Bu_{t-1}\)</span></center><br />t时刻P协方差预测：<br /><center><span class="math inline">\(P_t^- = FP_{t-1}F^T + Q\)</span></center><br />4.状态更新阶段<br />（1）<br /><center><span class="math inline">\(\hat{x_t} = \hat{x_t^-}+K_t(z_t -H\hat{x_t^-})\)</span></center><br />xt为<strong>最终滤波结果</strong>，xt-为先验估计，Kt卡尔曼增益，zt观测值<br />（2）更新卡尔曼增益<br /><center><span class="math inline">\(K_t=P_t^-H^T(HP^-_tH^T + R)^{-1}\)</span></center><br />P为先验协方差R观察量协方差矩阵（观测噪声）。<br />(3)<br /><center><span class="math inline">\(P_t = (I - K_tH)P_t^-\)</span></center><h2 id="三.mpu6050卡尔曼滤波姿态解算">三.MPU6050卡尔曼滤波姿态解算</h2><p>注：无法对yaw轴进行卡尔曼算法，需要9轴IMU借助磁力计进行解算<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kalman_cal.h&quot;</span></span><br><br><span class="hljs-comment">//卡尔曼解算法库</span><br><br><span class="hljs-type">short</span> aacx,aacy,aacz;<span class="hljs-comment">//加速度传感器原始数据 </span><br><span class="hljs-type">short</span> gyrox,gyroy,gyroz;<span class="hljs-comment">//陀螺仪原始数据 </span><br><span class="hljs-type">short</span> temperature;<span class="hljs-comment">//陀螺仪温度数据</span><br><span class="hljs-type">float</span> accel_x;     <span class="hljs-comment">//X轴加速度值</span><br><span class="hljs-type">float</span> accel_y;    <span class="hljs-comment">//Y轴加速度值</span><br><span class="hljs-type">float</span> accel_z;     <span class="hljs-comment">//Z轴加速度值</span><br><span class="hljs-type">float</span> gyro_x;<span class="hljs-comment">//X轴陀螺仪角速度数据</span><br><span class="hljs-type">float</span> gyro_y;        <span class="hljs-comment">//Y轴陀螺仪角速度数据</span><br><span class="hljs-type">float</span> gyro_z; <span class="hljs-comment">//Z轴陀螺仪角速度数据</span><br><span class="hljs-type">float</span> yaw_raw;   <span class="hljs-comment">//航线角yaw原始数据</span><br><span class="hljs-type">float</span> yaw_kalman;  <span class="hljs-comment">//yaw滤波后数据</span><br><span class="hljs-type">float</span> pitch_raw;   <span class="hljs-comment">//俯仰角pitch原始数据</span><br><span class="hljs-type">float</span> pitch_kalman;  <span class="hljs-comment">//pitch滤波后数据</span><br><span class="hljs-type">float</span> roll_raw;     <span class="hljs-comment">//横滚角roll原始数据</span><br><span class="hljs-type">float</span> roll_kalman;  <span class="hljs-comment">//roll滤波后数据</span><br><br><span class="hljs-type">rt_int16_t</span> temp;        <span class="hljs-comment">//温度</span><br><span class="hljs-type">rt_int16_t</span> gx,gy,gz;    <span class="hljs-comment">//三轴加速度</span><br><span class="hljs-type">rt_int16_t</span> ax,ay,az;    <span class="hljs-comment">//三轴角速度</span><br><span class="hljs-comment">//判断数据接收是否正常</span><br><span class="hljs-type">rt_err_t</span> temp_ret;<br><span class="hljs-type">rt_err_t</span> a_ret;<br><span class="hljs-type">rt_err_t</span> g_ret;<br><br><span class="hljs-comment">//陀螺仪数据计算</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Angle_Cal</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">//1. 原始数据获取</span><br><span class="hljs-type">float</span> accx,accy,accz;<span class="hljs-comment">//三方向角加速度值</span><br><span class="hljs-comment">//获取温度</span><br>  temp_ret = mpu6050_temperature_get(&amp;temp);    <br><span class="hljs-comment">//获取加速度传感器数据</span><br>  a_ret = mpu6050_accelerometer_get(&amp;ax, &amp;ay, &amp;az);<br>  <span class="hljs-comment">//获得陀螺仪数据</span><br>g_ret = mpu6050_gyroscope_get(&amp;gx, &amp;gy, &amp;gz);<br>accel_x = ax;<span class="hljs-comment">//x轴加速度值暂存</span><br>accel_y = ay;<span class="hljs-comment">//y轴加速度值暂存</span><br>accel_z = az;<span class="hljs-comment">//z轴加速度值暂存</span><br>gyro_x  = gx;<span class="hljs-comment">//x轴陀螺仪值暂存</span><br>gyro_y  = gy;<span class="hljs-comment">//y轴陀螺仪值暂存</span><br>gyro_z  = gz;<span class="hljs-comment">//z轴陀螺仪值暂存</span><br><br><span class="hljs-comment">//2.角加速度原始值处理过程</span><br><span class="hljs-comment">//加速度传感器配置寄存器0X1C内写入0x01,设置范围为±2g。换算关系：2^16/4 = 16384LSB/g</span><br><span class="hljs-keyword">if</span>(accel_x&lt;<span class="hljs-number">32764</span>) accx=accel_x/<span class="hljs-number">16384.0</span>;<span class="hljs-comment">//计算x轴加速度</span><br><span class="hljs-keyword">else</span>              accx=<span class="hljs-number">1</span>-(accel_x<span class="hljs-number">-49152</span>)/<span class="hljs-number">16384.0</span>;<br><span class="hljs-keyword">if</span>(accel_y&lt;<span class="hljs-number">32764</span>) accy=accel_y/<span class="hljs-number">16384.0</span>;<span class="hljs-comment">//计算y轴加速度</span><br><span class="hljs-keyword">else</span>              accy=<span class="hljs-number">1</span>-(accel_y<span class="hljs-number">-49152</span>)/<span class="hljs-number">16384.0</span>;<br><span class="hljs-keyword">if</span>(accel_z&lt;<span class="hljs-number">32764</span>) accz=accel_z/<span class="hljs-number">16384.0</span>;<span class="hljs-comment">//计算z轴加速度</span><br><span class="hljs-keyword">else</span>              accz=(accel_z<span class="hljs-number">-49152</span>)/<span class="hljs-number">16384.0</span>;<br><span class="hljs-comment">//加速度反正切公式计算三个轴和水平面坐标系之间的夹角</span><br>pitch_raw=(<span class="hljs-built_in">atan</span>(accy/accz))*<span class="hljs-number">180</span>/<span class="hljs-number">3.14</span>;<br>roll_raw=(<span class="hljs-built_in">atan</span>(accx/accz))*<span class="hljs-number">180</span>/<span class="hljs-number">3.14</span>;<br><span class="hljs-comment">//判断计算后角度的正负号</span><br><span class="hljs-keyword">if</span>(accel_x&lt;<span class="hljs-number">32764</span>) roll_raw = +roll_raw;<br><span class="hljs-keyword">if</span>(accel_x&gt;<span class="hljs-number">32764</span>) roll_raw = -roll_raw;<br><span class="hljs-keyword">if</span>(accel_y&lt;<span class="hljs-number">32764</span>) pitch_raw = +pitch_raw;<br><span class="hljs-keyword">if</span>(accel_y&gt;<span class="hljs-number">32764</span>) pitch_raw = -pitch_raw;<br><br><span class="hljs-comment">//3.角速度原始值处理过程</span><br><span class="hljs-comment">//陀螺仪配置寄存器0X1B内写入0x18，设置范围为±2000deg/s。换算关系：2^16/4000=16.4LSB/(°/S)</span><br><span class="hljs-comment">////计算角速度</span><br><span class="hljs-keyword">if</span>(gyro_x&lt;<span class="hljs-number">32768</span>) gyro_x=-(gyro_x/<span class="hljs-number">16.4</span>);<br><span class="hljs-keyword">if</span>(gyro_x&gt;<span class="hljs-number">32768</span>) gyro_x=+(<span class="hljs-number">65535</span>-gyro_x)/<span class="hljs-number">16.4</span>;<br><span class="hljs-keyword">if</span>(gyro_y&lt;<span class="hljs-number">32768</span>) gyro_y=-(gyro_y/<span class="hljs-number">16.4</span>);<br><span class="hljs-keyword">if</span>(gyro_y&gt;<span class="hljs-number">32768</span>) gyro_y=+(<span class="hljs-number">65535</span>-gyro_y)/<span class="hljs-number">16.4</span>;<br><span class="hljs-keyword">if</span>(gyro_z&lt;<span class="hljs-number">32768</span>) gyro_z=-(gyro_z/<span class="hljs-number">16.4</span>);<br><span class="hljs-keyword">if</span>(gyro_z&gt;<span class="hljs-number">32768</span>) gyro_z=+(<span class="hljs-number">65535</span>-gyro_z)/<span class="hljs-number">16.4</span>;<br><br><span class="hljs-comment">//4.调用卡尔曼函数</span><br>Kalman_Cal_Pitch(pitch_raw,gyro_x);  <span class="hljs-comment">//卡尔曼滤波计算X倾角</span><br>Kalman_Cal_Roll(roll_raw,gyro_y);  <span class="hljs-comment">//卡尔曼滤波计算Y倾角  </span><br><br><br>&#125;<br> <br><span class="hljs-comment">//卡尔曼参数</span><br><span class="hljs-type">static</span> <span class="hljs-type">float</span> Q_angle = <span class="hljs-number">0.001</span>;<span class="hljs-comment">//角度数据置信度，角度噪声的协方差</span><br><span class="hljs-type">static</span> <span class="hljs-type">float</span> Q_gyro  = <span class="hljs-number">0.003</span>;<span class="hljs-comment">//角速度数据置信度，角速度噪声的协方差  </span><br><span class="hljs-type">static</span> <span class="hljs-type">float</span> R_angle = <span class="hljs-number">0.5</span>;<span class="hljs-comment">//加速度计测量噪声的协方差</span><br><span class="hljs-type">static</span> <span class="hljs-type">float</span> dt      = <span class="hljs-number">0.01</span>;<span class="hljs-comment">//采样周期即计算任务周期10ms</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Kalman_Cal_Pitch</span><span class="hljs-params">(<span class="hljs-type">float</span> acc,<span class="hljs-type">float</span> gyro)</span> <span class="hljs-comment">//卡尔曼滤波pitch轴计算</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">float</span> Q_bias;<span class="hljs-comment">//Q_bias:陀螺仪的偏差</span><br><span class="hljs-type">static</span> <span class="hljs-type">float</span> K_0, K_1;<span class="hljs-comment">//卡尔曼增益  K_0:用于计算最优估计值  K_1:用于计算最优估计值的偏差 t_0/1:中间变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">float</span> PP[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;,&#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125; &#125;;<span class="hljs-comment">//过程协方差矩阵P，初始值为单位阵</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">卡尔曼滤波的使用步骤</span><br><span class="hljs-comment">(1) 选择状态量、观测量</span><br><span class="hljs-comment">(2) 构建方程</span><br><span class="hljs-comment">(3) 初始化参数</span><br><span class="hljs-comment">(4) 带入公式迭代</span><br><span class="hljs-comment">(5) 调节超参数P、Q</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">X(k)：k时刻系统状态Z(k)：k时刻测量值</span><br><span class="hljs-comment">U(k)：k时刻对系统控制量H：测量系统参数</span><br><span class="hljs-comment"> 方差</span><br><span class="hljs-comment">A/F：状态转移矩阵W(k)：过程噪声 ----&gt; Q</span><br><span class="hljs-comment"> 方差</span><br><span class="hljs-comment">B：控制矩阵V(k)：测量噪声 ----&gt; R</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">离散控制系统</span><br><span class="hljs-comment">系统描述：X(k|k-1) = AX(k-1|k-1) + BU(k) + (W(k))</span><br><span class="hljs-comment">测量值：Z(k) = HX(k) + V(k)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 先验估计</span><br><span class="hljs-comment">* * *公式1：X(k|k-1) = AX(k-1|k-1) + BU(k) + (W(k))</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">X = (Angle,Q_bias)</span><br><span class="hljs-comment">A(1,1) = 1,A(1,2) = -dt</span><br><span class="hljs-comment">A(2,1) = 0,A(2,2) = 1</span><br><span class="hljs-comment">注：上下连“[”代表矩阵</span><br><span class="hljs-comment">预测当前角度值：</span><br><span class="hljs-comment">[ angle ] [1 -dt][ angle ] [dt]</span><br><span class="hljs-comment">[ Q_bias] = [0  1 ][ Q_bias] + [ 0] * newGyro(加速度计测量值)</span><br><span class="hljs-comment">故</span><br><span class="hljs-comment">angle = angle - Q_bias*dt + newGyro * dt</span><br><span class="hljs-comment">Q_bias = Q_bias</span><br><span class="hljs-comment">*/</span><br>pitch_kalman += (gyro - Q_bias) * dt; <span class="hljs-comment">//状态方程,角度值等于上次最优角度加角速度减零漂后积分</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">2. 预测协方差矩阵</span><br><span class="hljs-comment">* * *公式2：P(k|k-1)=AP(k-1|k-1)A^T + Q </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">由先验估计有系统参数</span><br><span class="hljs-comment">[1 -dt]</span><br><span class="hljs-comment">A = [0  1 ]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">系统过程协方差噪声Q定义：</span><br><span class="hljs-comment">| cov(angle,angle)  cov(Q_bias,angle) |</span><br><span class="hljs-comment">|cov(angle,Q_bias) cov(Q_bias,Q_bias)|</span><br><span class="hljs-comment"> 角度噪声和角速度漂移噪声相互独立</span><br><span class="hljs-comment">| D( angle )  0  |</span><br><span class="hljs-comment">= |0 D( Q_bias )|</span><br><span class="hljs-comment">又Q_angle和Q_bias的方差为常数，</span><br><span class="hljs-comment">可由经验或计算得出</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">令D( angle )  = Q_angle </span><br><span class="hljs-comment">D( Q_bias ) = Q_gyro </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">设上一次预测协方差矩阵为P(k-1)</span><br><span class="hljs-comment">|a(k-1)  b(k-1)|</span><br><span class="hljs-comment">|c(k-1)  d(k-1)|</span><br><span class="hljs-comment">本次预测协方差矩阵P(k)</span><br><span class="hljs-comment">|a(k)  b(k)|</span><br><span class="hljs-comment">                  |c(k)  d(k)|</span><br><span class="hljs-comment">由公式2：P(k|k-1)=AP(k-1|k-1)A^T + Q 得</span><br><span class="hljs-comment">|a(k)  b(k)||1 -dt||a(k-1) b(k-1)| |1  0|| D( angle )  0  |</span><br><span class="hljs-comment">|c(k)  d(k)| =  |0  1 | |c(k-1) d(k-1)| |-dt 1| + |0 D( Q_bias )|</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">进一步得</span><br><span class="hljs-comment">|a(k)  b(k)||a(k-1) - [c(k-1) + b(k-1)]*dt + d(dt)^2b(k-1) - d(k-1)*dt|| D( angle )  0  |</span><br><span class="hljs-comment">  |c(k)  d(k)| =  |c(k-1) - d(k-1)*dtd(k-1)| + |0 D( Q_bias )|</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">由于dt^2太小，故dt^2省略</span><br><span class="hljs-comment">*/</span><br><br>PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + Q_angle - (PP[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + PP[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])*dt;<br>PP[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = PP[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - PP[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]*dt;<br>PP[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = PP[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - PP[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]*dt;<br>PP[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = PP[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + Q_gyro;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">3. 建立测量方程</span><br><span class="hljs-comment">系统测量方程 Z(k) = HX(k) + V(k)</span><br><span class="hljs-comment">系统测量系数 H = [1, 0]</span><br><span class="hljs-comment">因为陀螺仪输出自带噪声</span><br><span class="hljs-comment">所以</span><br><span class="hljs-comment">measure = newAngle</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">4. 计算卡尔曼增益</span><br><span class="hljs-comment">* * *公式3：Kg(k)= P(k|k-1)H^T/(HP(k|k-1)H^T+R)</span><br><span class="hljs-comment">Kg = (K_0,K_1) 对应angle,Q_bias增益</span><br><span class="hljs-comment">H = (1,0)</span><br><span class="hljs-comment">*/</span><br>K_0 = PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] / (PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + R_angle);<br>K_1 = PP[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] / (PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + R_angle);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">5. 计算当前最优化估计值</span><br><span class="hljs-comment">* * *公式4：X(k|k) = X(k|k-1) + kg(k)[z(k) - HX(k|k-1)]</span><br><span class="hljs-comment">angle = angle + K_0*(newAngle - angle)</span><br><span class="hljs-comment">Q_bias = Q_bias + K_1*(newAngle - angle)</span><br><span class="hljs-comment">*/</span><br><br>pitch_kalman = pitch_kalman + K_0 * (acc - pitch_kalman);<br>Q_bias = Q_bias + K_1 * (acc - pitch_kalman);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">6. 更新协方差矩阵</span><br><span class="hljs-comment">* * *公式5：P(k|k)=[I-Kg(k)H]P(k|k-1)</span><br><span class="hljs-comment">*/</span><br>PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - K_0 * PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>PP[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = PP[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - K_0 * PP[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>PP[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = PP[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - K_1 * PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>PP[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = PP[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - K_1 * PP[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Kalman_Cal_Roll</span><span class="hljs-params">(<span class="hljs-type">float</span> acc,<span class="hljs-type">float</span> gyro)</span> <span class="hljs-comment">//卡尔曼滤波roll轴计算</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">float</span> Q_bias;<span class="hljs-comment">//Q_bias:陀螺仪的偏差  Angle_err:角度偏量 </span><br><span class="hljs-type">static</span> <span class="hljs-type">float</span> K_0, K_1;<span class="hljs-comment">//卡尔曼增益  K_0:用于计算最优估计值  K_1:用于计算最优估计值的偏差 t_0/1:中间变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">float</span> PP[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;,&#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125; &#125;;<span class="hljs-comment">//过程协方差矩阵P，初始值为单位阵</span><br>roll_kalman += (gyro - Q_bias) * dt; <span class="hljs-comment">//状态方程,角度值等于上次最优角度加角速度减零漂后积分</span><br>PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + Q_angle - (PP[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + PP[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])*dt;<br>PP[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = PP[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - PP[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]*dt;<br>PP[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = PP[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - PP[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]*dt;<br>PP[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = PP[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + Q_gyro;<br>K_0 = PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] / (PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + R_angle);<br>K_1 = PP[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] / (PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + R_angle);<br>roll_kalman = roll_kalman + K_0 * (acc - roll_kalman);<br>Q_bias = Q_bias + K_1 * (acc - roll_kalman);<br>PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - K_0 * PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>PP[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = PP[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - K_0 * PP[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>PP[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = PP[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - K_1 * PP[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>PP[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = PP[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - K_1 * PP[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>&#125;<br><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS</title>
    <link href="/2023/11/20/FreeRTOS/"/>
    <url>/2023/11/20/FreeRTOS/</url>
    
    <content type="html"><![CDATA[<h2 id="一.stm32f103系统移植">一.stm32f103系统移植</h2><p>此过程可以由CubeMX替代，选择对应的芯片后点击 Middlewares 勾选FreeRTOS 选项即可。生成代码时自动加入 FreeRTOS</p><p>FreeRTOSConfig.h配置文件添加中断函数： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortPendSVHandler PendSV_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortSysTickHandler SysTick_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vPortSVCHandler SVC_Handler</span><br></code></pre></td></tr></table></figure>相应的，注销掉原有的中断： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* void SVC_Handler(void) */</span><br><span class="hljs-comment">/* &#123; */</span><br><span class="hljs-comment">/* &#125; */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  This function handles Debug Monitor exception.</span><br><span class="hljs-comment">  * @param  None</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DebugMon_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  This function handles PendSVC exception.</span><br><span class="hljs-comment">  * @param  None</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-comment">/* void PendSV_Handler(void) */</span><br><span class="hljs-comment">/* &#123; */</span><br><span class="hljs-comment">/* &#125; */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  This function handles SysTick Handler.</span><br><span class="hljs-comment">  * @param  None</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-comment">/* void SysTick_Handler(void) */</span><br><span class="hljs-comment">/* &#123; */</span><br><span class="hljs-comment">/* &#125; */</span><br></code></pre></td></tr></table></figure></p><h2 id="二.动态任务创建和删除">二.动态任务创建和删除</h2><p>宏定义typedef tskTCB TCB_t; taskTCB就是TCB_t<br />创建一个任务：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskCreate</span><span class="hljs-params">( TaskFunction_t pxTaskCode,</span><br><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, <span class="hljs-comment">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span></span><br><span class="hljs-params">                            <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth,</span><br><span class="hljs-params">                            <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters,</span><br><span class="hljs-params">                            UBaseType_t uxPriority,</span><br><span class="hljs-params">                            TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask )</span><br></code></pre></td></tr></table></figure> para1: pxTaskCode为任务函数名称(TaskFunction_t)start_task<br />para2: "字符串为任务名称"<br />para3:uint16_t代表堆栈中的大小（单位：字 = 4字节）<br />para4: 任务参数usually NULL<br />para5:优先级0~31，数值越大优先级越高<br />para6：任务句柄<br />xTaskCreate()函数的实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )<span class="hljs-comment">//条件编译：需要在config文件中定义宏 configSUPPORT_DYNAMIC_ALLOCATION</span></span><br><br>    BaseType_t <span class="hljs-title function_">xTaskCreate</span><span class="hljs-params">( TaskFunction_t pxTaskCode,</span><br><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, <span class="hljs-comment">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span></span><br><span class="hljs-params">                            <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth,</span><br><span class="hljs-params">                            <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters,</span><br><span class="hljs-params">                            UBaseType_t uxPriority,</span><br><span class="hljs-params">                            TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask )</span><br>    &#123;<br>        TCB_t * pxNewTCB;<span class="hljs-comment">//任务控制块：1.pxOfStackTop任务栈栈顶2.StateList 3.EventList4.uxPriority任务优先级</span><br>        BaseType_t xReturn;<br><br>        <span class="hljs-comment">/* If the stack grows down then allocate the stack then the TCB so the stack</span><br><span class="hljs-comment">         * does not grow into the TCB.  Likewise if the stack grows up then allocate</span><br><span class="hljs-comment">         * the TCB then the stack. */</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portSTACK_GROWTH &gt; 0 )<span class="hljs-comment">//栈从高到低，堆由低到高(malloc)</span></span><br>        &#123;<br>            <span class="hljs-comment">/* Allocate space for the TCB.  Where the memory comes from depends on</span><br><span class="hljs-comment">             * the implementation of the port malloc function and whether or not static</span><br><span class="hljs-comment">             * allocation is being used. */</span><br>            pxNewTCB = ( TCB_t * ) pvPortMalloc( <span class="hljs-keyword">sizeof</span>( TCB_t ) );<br><br>            <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<br>            &#123;<br>                <span class="hljs-built_in">memset</span>( ( <span class="hljs-type">void</span> * ) pxNewTCB, <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>( TCB_t ) );<br><br>                <span class="hljs-comment">/* Allocate space for the stack used by the task being created.</span><br><span class="hljs-comment">                 * The base of the stack memory stored in the TCB so the task can</span><br><span class="hljs-comment">                 * be deleted later if required. */</span><br>                pxNewTCB-&gt;pxStack = ( StackType_t * ) pvPortMallocStack( ( ( ( <span class="hljs-type">size_t</span> ) usStackDepth ) * <span class="hljs-keyword">sizeof</span>( StackType_t ) ) ); <span class="hljs-comment">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span><br><br>                <span class="hljs-keyword">if</span>( pxNewTCB-&gt;pxStack == <span class="hljs-literal">NULL</span> )<br>                &#123;<br>                    <span class="hljs-comment">/* Could not allocate the stack.  Delete the allocated TCB. */</span><br>                    vPortFree( pxNewTCB );<br>                    pxNewTCB = <span class="hljs-literal">NULL</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br>        &#123;<br>            StackType_t * pxStack;<br><br>            <span class="hljs-comment">/* Allocate space for the stack used by the task being created. */</span><br>            pxStack = pvPortMallocStack( ( ( ( <span class="hljs-type">size_t</span> ) usStackDepth ) * <span class="hljs-keyword">sizeof</span>( StackType_t ) ) ); <span class="hljs-comment">/*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU&#x27;s stack and this allocation is the stack. */</span><br>                                                                                <span class="hljs-comment">// StackType_t 为 uint32_t，单位为4字节=字</span><br>            <span class="hljs-keyword">if</span>( pxStack != <span class="hljs-literal">NULL</span> )<br>            &#123;<br>                <span class="hljs-comment">/* Allocate space for the TCB. */</span><br>                pxNewTCB = ( TCB_t * ) pvPortMalloc( <span class="hljs-keyword">sizeof</span>( TCB_t ) ); <span class="hljs-comment">/*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU&#x27;s stack, and the first member of TCB_t is always a pointer to the task&#x27;s stack. */</span><br><br>                <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<span class="hljs-comment">//如果申请成功</span><br>                &#123;<br>                    <span class="hljs-built_in">memset</span>( ( <span class="hljs-type">void</span> * ) pxNewTCB, <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>( TCB_t ) );<br><br>                    <span class="hljs-comment">/* Store the stack location in the TCB. */</span><br>                    pxNewTCB-&gt;pxStack = pxStack;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">/* The stack cannot be used as the TCB was not created.  Free</span><br><span class="hljs-comment">                     * it again. */</span><br>                    vPortFreeStack( pxStack );<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                pxNewTCB = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br><br>        <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) <span class="hljs-comment">/*lint !e9029 !e731 Macro has been consolidated for readability reasons. */</span></span><br>            &#123;<br>                <span class="hljs-comment">/* Tasks can be created statically or dynamically, so note this</span><br><span class="hljs-comment">                 * task was created dynamically in case it is later deleted. */</span><br>                pxNewTCB-&gt;ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;<br>            &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */</span></span><br><br>            prvInitialiseNewTask( pxTaskCode, pcName, ( <span class="hljs-type">uint32_t</span> ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, <span class="hljs-literal">NULL</span> );<br>            prvAddNewTaskToReadyList( pxNewTCB );<span class="hljs-comment">//添加到就序列表</span><br>            xReturn = pdPASS;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> xReturn;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configSUPPORT_DYNAMIC_ALLOCATION */</span></span><br></code></pre></td></tr></table></figure> 初始化TCB prvInitialiseNewTask():</p><p>prv前缀（private），因为函数被static修饰只在当前文件可见<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvInitialiseNewTask</span><span class="hljs-params">( TaskFunction_t pxTaskCode,</span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, <span class="hljs-comment">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span></span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> ulStackDepth,</span><br><span class="hljs-params">                                  <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters,</span><br><span class="hljs-params">                                  UBaseType_t uxPriority,</span><br><span class="hljs-params">                                  TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask,</span><br><span class="hljs-params">                                  TCB_t * pxNewTCB,</span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> MemoryRegion_t * <span class="hljs-type">const</span> xRegions )</span><br>&#123;<br>    StackType_t * pxTopOfStack;<br>    UBaseType_t x;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span><br>        <span class="hljs-comment">/* Should the task be created in privileged mode? */</span><br>        BaseType_t xRunPrivileged;<br><br>        <span class="hljs-keyword">if</span>( ( uxPriority &amp; portPRIVILEGE_BIT ) != <span class="hljs-number">0U</span> )<br>        &#123;<br>            xRunPrivileged = pdTRUE;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            xRunPrivileged = pdFALSE;<br>        &#125;<br>        uxPriority &amp;= ~portPRIVILEGE_BIT;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* portUSING_MPU_WRAPPERS == 1 */</span></span><br><br>    <span class="hljs-comment">/* Avoid dependency on memset() if it is not required. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )</span><br>    &#123;<br>        <span class="hljs-comment">/* Fill the stack with a known value to assist debugging.从pxStack起始地址开始赋值为0xA5，可用API检测历史剩余最小栈空间 */</span><br>        ( <span class="hljs-type">void</span> ) <span class="hljs-built_in">memset</span>( pxNewTCB-&gt;pxStack, ( <span class="hljs-type">int</span> ) tskSTACK_FILL_BYTE, ( <span class="hljs-type">size_t</span> ) ulStackDepth * <span class="hljs-keyword">sizeof</span>( StackType_t ) );<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* tskSET_NEW_STACKS_TO_KNOWN_VALUE */</span></span><br><br>    <span class="hljs-comment">/* Calculate the top of stack address.  This depends on whether the stack</span><br><span class="hljs-comment">     * grows from high memory to low (as per the 80x86) or vice versa.</span><br><span class="hljs-comment">     * portSTACK_GROWTH is used to make the result positive or negative as required</span><br><span class="hljs-comment">     * by the port. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portSTACK_GROWTH &lt; 0 )<span class="hljs-comment">//从上到下</span></span><br>    &#123;<br>        pxTopOfStack = &amp;( pxNewTCB-&gt;pxStack[ ulStackDepth - ( <span class="hljs-type">uint32_t</span> ) <span class="hljs-number">1</span> ] );<br>        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); <span class="hljs-comment">/*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */</span><br><br>        <span class="hljs-comment">/* Check the alignment of the calculated top of stack is correct. */</span><br>        configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == <span class="hljs-number">0UL</span> ) );<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configRECORD_STACK_HIGH_ADDRESS == 1 )</span><br>        &#123;<br>            <span class="hljs-comment">/* Also record the stack&#x27;s high address, which may assist</span><br><span class="hljs-comment">             * debugging. */</span><br>            pxNewTCB-&gt;pxEndOfStack = pxTopOfStack;<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configRECORD_STACK_HIGH_ADDRESS */</span></span><br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br>    &#123;<br>        pxTopOfStack = pxNewTCB-&gt;pxStack;<br><br>        <span class="hljs-comment">/* Check the alignment of the stack buffer is correct. */</span><br>        configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB-&gt;pxStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == <span class="hljs-number">0UL</span> ) );<br><br>        <span class="hljs-comment">/* The other extreme of the stack space is required if stack checking is</span><br><span class="hljs-comment">         * performed. */</span><br>        pxNewTCB-&gt;pxEndOfStack = pxNewTCB-&gt;pxStack + ( ulStackDepth - ( <span class="hljs-type">uint32_t</span> ) <span class="hljs-number">1</span> );<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br><br>    <span class="hljs-comment">/* Store the task name in the TCB. */</span><br>    <span class="hljs-keyword">if</span>( pcName != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-keyword">for</span>( x = ( UBaseType_t ) <span class="hljs-number">0</span>; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )<br>        &#123;<br>            pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];<br><br>            <span class="hljs-comment">/* Don&#x27;t copy all configMAX_TASK_NAME_LEN if the string is shorter than</span><br><span class="hljs-comment">             * configMAX_TASK_NAME_LEN characters just in case the memory after the</span><br><span class="hljs-comment">             * string is not accessible (extremely unlikely). */</span><br>            <span class="hljs-keyword">if</span>( pcName[ x ] == ( <span class="hljs-type">char</span> ) <span class="hljs-number">0x00</span> )<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/* Ensure the name string is terminated in the case that the string length</span><br><span class="hljs-comment">         * was greater or equal to configMAX_TASK_NAME_LEN. */</span><br>        pxNewTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - <span class="hljs-number">1</span> ] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br><br>    <span class="hljs-comment">/* This is used as an array index so must ensure it&#x27;s not too large. */</span><br>    configASSERT( uxPriority &lt; configMAX_PRIORITIES );<br><br>    <span class="hljs-keyword">if</span>( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )<br>    &#123;<br>        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) <span class="hljs-number">1U</span>; <span class="hljs-comment">//超出最大优先级，会赋值为32-1=31</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br><br>    pxNewTCB-&gt;uxPriority = uxPriority;<span class="hljs-comment">//赋值给TCB成员</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_MUTEXES == 1 )</span><br>    &#123;<br>        pxNewTCB-&gt;uxBasePriority = uxPriority;<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_MUTEXES */</span></span><br><br>    vListInitialiseItem( &amp;( pxNewTCB-&gt;xStateListItem ) );<span class="hljs-comment">//初始化状态列表</span><br>    vListInitialiseItem( &amp;( pxNewTCB-&gt;xEventListItem ) );<span class="hljs-comment">//初始化事件列表</span><br><br>    <span class="hljs-comment">/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get</span><br><span class="hljs-comment">     * back to  the containing TCB from a generic item in a list. */</span><br>    listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xStateListItem ), pxNewTCB );<br><br>    <span class="hljs-comment">/* Event lists are always in priority order. */</span><br>    <span class="hljs-comment">//事件列表按照从小到大排列</span><br>    <span class="hljs-comment">//对列表中的任务倒置maxPrio - taskPrio得到正确的顺序</span><br>    listSET_LIST_ITEM_VALUE( &amp;( pxNewTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); <span class="hljs-comment">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span><br>    listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xEventListItem ), pxNewTCB );<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span><br>    &#123;<br>        vPortStoreTaskMPUSettings( &amp;( pxNewTCB-&gt;xMPUSettings ), xRegions, pxNewTCB-&gt;pxStack, ulStackDepth );<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    &#123;<br>        <span class="hljs-comment">/* Avoid compiler warning about unreferenced parameter. */</span><br>        ( <span class="hljs-type">void</span> ) xRegions;<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( configUSE_NEWLIB_REENTRANT == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) )</span><br>    &#123;<br>        <span class="hljs-comment">/* Allocate and initialize memory for the task&#x27;s TLS Block. */</span><br>        configINIT_TLS_BLOCK( pxNewTCB-&gt;xTLSBlock );<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* Initialize the TCB stack to look as if the task was already running,</span><br><span class="hljs-comment">     * but had been interrupted by the scheduler.  The return address is set</span><br><span class="hljs-comment">     * to the start of the task function. Once the stack has been initialised</span><br><span class="hljs-comment">     * the top of stack variable is updated. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span><br>    &#123;<br>        <span class="hljs-comment">/* If the port has capability to detect stack overflow,</span><br><span class="hljs-comment">         * pass the stack end address to the stack initialization</span><br><span class="hljs-comment">         * function as well. */</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portHAS_STACK_OVERFLOW_CHECKING == 1 )</span><br>        &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portSTACK_GROWTH &lt; 0 )</span><br>            &#123;<br>                pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-&gt;pxStack, pxTaskCode, pvParameters, xRunPrivileged );<br>            &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br>            &#123;<br>                pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-&gt;pxEndOfStack, pxTaskCode, pvParameters, xRunPrivileged );<br>            &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* portHAS_STACK_OVERFLOW_CHECKING */</span></span><br>        &#123;<br>            <span class="hljs-comment">//初始化任务栈栈顶****</span><br>            pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* portHAS_STACK_OVERFLOW_CHECKING */</span></span><br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* portUSING_MPU_WRAPPERS */</span></span><br>    &#123;<br>        <span class="hljs-comment">/* If the port has capability to detect stack overflow,</span><br><span class="hljs-comment">         * pass the stack end address to the stack initialization</span><br><span class="hljs-comment">         * function as well. */</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portHAS_STACK_OVERFLOW_CHECKING == 1 )</span><br>        &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portSTACK_GROWTH &lt; 0 )</span><br>            &#123;<br>                pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-&gt;pxStack, pxTaskCode, pvParameters );<br>            &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br>            &#123;<br>                pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-&gt;pxEndOfStack, pxTaskCode, pvParameters );<br>            &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* portHAS_STACK_OVERFLOW_CHECKING */</span></span><br>        &#123;<br>            pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* portHAS_STACK_OVERFLOW_CHECKING */</span></span><br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* portUSING_MPU_WRAPPERS */</span></span><br><br>    <span class="hljs-keyword">if</span>( pxCreatedTask != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-comment">/* Pass the handle out in an anonymous way.  The handle can be used to</span><br><span class="hljs-comment">         * change the created task&#x27;s priority, delete the created task, etc.*/</span><br>        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br>&#125;<br>/<br></code></pre></td></tr></table></figure> example:实现两只小灯同时闪烁 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> START_TASK_STACK_SIZE 128<span class="hljs-comment">//开始任务堆栈大小</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> START_TASK_PRIORITY   1<span class="hljs-comment">//开始任务优先级</span></span><br>TaskHandle_t StartTask_Handler;<span class="hljs-comment">//开始任务句柄，类型TaskHandle_t</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_1_STACK_SIZE 128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_1_PRIORITY   2</span><br>TaskHandle_t Task1_Handler;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_2_STACK_SIZE 128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_2_PRIORITY   3</span><br>TaskHandle_t Task2_Handler;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">RTOS_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    xTaskCreate((TaskFunction_t)startTask, <span class="hljs-string">&quot;StartTask&quot;</span>,<br>                START_TASK_STACK_SIZE, <span class="hljs-literal">NULL</span>,<br>                START_TASK_PRIORITY, &amp;StartTask_Handler);<br>    vTaskStartScheduler();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">startTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    taskENTER_CRITICAL();<span class="hljs-comment">//通常创建任务时进入临界态，保证创建时不发生任务调度 </span><br>    xTaskCreate((TaskFunction_t)task1, <span class="hljs-string">&quot;Task1&quot;</span>,<br>                TASK_1_STACK_SIZE, <span class="hljs-literal">NULL</span>,<br>                TASK_1_PRIORITY, &amp;Task1_Handler);<br>    xTaskCreate((TaskFunction_t)task2, <span class="hljs-string">&quot;Task2&quot;</span>,<br>                TASK_2_STACK_SIZE, <span class="hljs-literal">NULL</span>,<br>                TASK_2_PRIORITY, &amp;Task2_Handler);<br>    vTaskDelete(<span class="hljs-literal">NULL</span>);<br>    taskEXIT_CRITICAL();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">task1</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<span class="hljs-comment">//pvParameters 任务参数指针</span><br>    LED_Init(GPIOC, GPIO_Pin_13);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        LED_Switch(GPIOC, GPIO_Pin_13);<br>        vTaskDelay(<span class="hljs-number">50</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">task2</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span> &#123;<br>    LED_Init(GPIOB, GPIO_Pin_12);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        LED_Switch(GPIOB, GPIO_Pin_12);<br>        vTaskDelay(<span class="hljs-number">50</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h3 id="拓展-cmsis-v2-提供的api接口">拓展: CMSIS-V2 提供的API接口</h3><p>在 CMSIS 规范中，FreeRTOS 的 Task 变成 Thread</p><p>任务句柄类型是 osThreaedId_t</p><p>初始化任务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">osThreadId_t defaultTaskHandle;<br><span class="hljs-type">const</span> osThreadAttr_t defaultTask_attributes = &#123;<br>  .name = <span class="hljs-string">&quot;defaultTask&quot;</span>,<br>  .stack_size = <span class="hljs-number">128</span> * <span class="hljs-number">4</span>,<br>  .priority = (osPriority_t) osPriorityNormal,<br>&#125;;<br><br>defaultTaskHandle = osThreadNew(StartDefaultTask, <span class="hljs-literal">NULL</span>, &amp;defaultTask_attributes);<br></code></pre></td></tr></table></figure><h2 id="三.静态创建任务">三.静态创建任务</h2><p>任务函数不需要修改<br />手动实现空闲任务和定时器任务及其TCB：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vApplicationGetIdleTaskMemory</span><span class="hljs-params">(StaticTask_t **ppxIdleTaskTCBBuffer,</span><br><span class="hljs-params">                                   StackType_t **ppxIdleTaskStackBuffer,</span><br><span class="hljs-params">                                   <span class="hljs-type">uint32_t</span> *pulIdleTaskStackSize)</span> &#123;<br>    <span class="hljs-type">static</span> StaticTask_t xIdleTaskTCB;<br>    <span class="hljs-type">static</span> StackType_t uxIdleTaskStack[configMINIMAL_STACK_SIZE];<br>    *ppxIdleTaskTCBBuffer = &amp;xIdleTaskTCB;<br>    *ppxIdleTaskStackBuffer = uxIdleTaskStack;<br>    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vApplicationGetTimerTaskMemory</span><span class="hljs-params">(StaticTask_t **ppxTimerTaskTCBBuffer,</span><br><span class="hljs-params">                                    StackType_t **ppxTimerTaskStackBuffer,</span><br><span class="hljs-params">                                    <span class="hljs-type">uint32_t</span> *pulTimerTaskStackSize)</span> &#123;<br>    <span class="hljs-type">static</span> StaticTask_t xTimerTaskTCB;<br>    <span class="hljs-type">static</span> StackType_t uxTimerTaskStack[configTIMER_TASK_STACK_DEPTH];<br>    *ppxTimerTaskTCBBuffer = &amp;xTimerTaskTCB;<br>    *ppxTimerTaskStackBuffer = uxTimerTaskStack;<br>    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;<br>&#125;<br></code></pre></td></tr></table></figure> 为什么需要实现这两个函数，我们在调用开启任务调度器时：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span><br>&#123;<br>    StaticTask_t * pxIdleTaskTCBBuffer = <span class="hljs-literal">NULL</span>;<br>    StackType_t * pxIdleTaskStackBuffer = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">uint32_t</span> ulIdleTaskStackSize;<br><br>    <span class="hljs-comment">/* The Idle task is created using user provided RAM - obtain the</span><br><span class="hljs-comment">     * address of the RAM then create the idle task. */</span><br>    vApplicationGetIdleTaskMemory( &amp;pxIdleTaskTCBBuffer, &amp;pxIdleTaskStackBuffer, &amp;ulIdleTaskStackSize );<br>    xIdleTaskHandle = xTaskCreateStatic( prvIdleTask,   <span class="hljs-comment">//返回值为任务句柄</span><br>                                         configIDLE_TASK_NAME,<br>                                         ulIdleTaskStackSize,<br>                                         ( <span class="hljs-type">void</span> * ) <span class="hljs-literal">NULL</span>,       <span class="hljs-comment">/*lint !e961.  The cast is not redundant for all compilers. */</span><br>                                         portPRIVILEGE_BIT,     <span class="hljs-comment">/* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */</span><br>                                         pxIdleTaskStackBuffer,<br>                                         pxIdleTaskTCBBuffer ); <span class="hljs-comment">/*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */</span><br></code></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span><br>&#123;<br>    StaticTask_t * pxTimerTaskTCBBuffer = <span class="hljs-literal">NULL</span>;<br>    StackType_t * pxTimerTaskStackBuffer = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">uint32_t</span> ulTimerTaskStackSize;<br><br>    vApplicationGetTimerTaskMemory( &amp;pxTimerTaskTCBBuffer, &amp;pxTimerTaskStackBuffer, &amp;ulTimerTaskStackSize );<br>    xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,<br>                                          configTIMER_SERVICE_TASK_NAME,<br>                                          ulTimerTaskStackSize,<br>                                          <span class="hljs-literal">NULL</span>,<br>                                          ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,<br>                                          pxTimerTaskStackBuffer,<br>                                          pxTimerTaskTCBBuffer );<br></code></pre></td></tr></table></figure> 需要手动实现两个函数，否则会编译报错</p><h2 id="四.任务的挂起与恢复">四.任务的挂起与恢复</h2><p>void vTaskSuspend(TaskHandle_t xTaskToSuspend) 任务挂起<br />voidvTaskResume(TaskHandle_t xTaskToResume) 任务恢复<br />BaseType_txTaskResumeFromISR(TaskHandle_t xTaskToResume)从中断中恢复任务<br />返回值 pdTrue:恢复后切换任务<br />pdFalse：恢复后不切换任务<br />中断优先级不能高于FreeRTOS所管理的最高优先级（5~15）</p><h2 id="五.freertos中断管理">五.FreeRTOS中断管理</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PID算法初见</title>
    <link href="/2023/11/12/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/"/>
    <url>/2023/11/12/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一-不懂">一 不懂</h2><p>P(roportion) I(ntegral) D(erivative)</p><p>比例 积分 微分</p><p>特点：无需对子系统进行精确的建模</p><h2 id="二-略懂">二 略懂</h2><ol type="1"><li></li></ol><p>A.开环控制系统</p><p>Desired output ------&gt; Controller-------&gt;Actuators------&gt;Plant ------&gt;Actual output X Uc Ua YB.前馈控制系统</p><p>2.闭环控制系统</p><p>A.单闭环<imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/pidimage.png" /></p><p>控制器E=X-Y，其中X为期望输出，Y来自传感器</p><p>B.双闭环</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/pidimage%20(1).png" /></p><p>Y1为外环控制，Y2为内环控制。</p><p>参数：</p><p>a.误差E(rror) = X （期望输出） - Y(实际)</p><p>b.控制器输出 c.执行器输出</p><h2 id="三-pid数学公式">三 PID数学公式</h2><center><span class="math inline">\(u(t) = \frac{1}{p}(e + \frac{1}{T_i}\int_0^t e \, \mathrm{d}t +T_d\,\frac{\mathrm{d}e}{\mathrm{d}t})\)</span></center><p>其中<span class="math inline">\(p \, T_i \,T_d\)</span>是需要调参的参数</p><p>也可以写成</p><center><span class="math inline">\(u(t)=K_pe +K_i\int_0^te\,\mathrm{d}t +K_d\frac{\mathrm{d}e}{\mathrm{d}t}\)</span>（连续函数）</center><center><span class="math inline">\(u(t)=K_pe_i +K_i\sum_{i=1}^Ne_i+K_d\frac{e_i - e_{i-1}}{\Deltat}\)</span>（离散函数）</center><h2 id="四-其他pid控制知识">四 其他PID控制知识</h2><p>1.积分限幅：防止积分项过大导致超出期望输出过多，导致系统紊乱</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/pidimage%20(2).png" /></p><p>假设ei为常数,p项始终不变，i项会移植增大，可用蓝色线作为积分限幅防止积分项过大。</p><p>2.积分分离：误差突变时，导致i项积分项也突变导致系统超调</p><p>当p向大于某一阈值时，让Ki = 0，积分项作用为零。</p><p>3.微分先行：传感器绕过PI项，直接输出给D项。</p><h2 id="五-c语言程序实现">五 C语言程序实现</h2><p>程序中通常使用增量式PID公式来减少运算量：</p><center><span class="math inline">\(\Delta u(k) = u(k) - u(k -1)=K_p(e_k -e_{k-1})+K_ie_k+K_d(e_k - 2e_{k - 1} + e_{k_2})\)</span><center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> Kp = <span class="hljs-number">1.0</span>, Ki = <span class="hljs-number">0.5</span>, Kd = <span class="hljs-number">0.1</span>;                                      <span class="hljs-comment">// PID系数</span><br><span class="hljs-type">float</span> error = <span class="hljs-number">0</span>, error_1 = <span class="hljs-number">0</span>, error_2 = <span class="hljs-number">0</span>, integral = <span class="hljs-number">0</span>, derivative = <span class="hljs-number">0</span>; <span class="hljs-comment">// 误差，上一次误差，上上次误差，积分，微分</span><br><span class="hljs-type">float</span> target = <span class="hljs-number">100</span>, current = <span class="hljs-number">0</span>;                                         <span class="hljs-comment">// 目标值，当前值</span><br><span class="hljs-type">int</span> pwmValue = <span class="hljs-number">0</span>, pwmMax = <span class="hljs-number">1000</span>;<br><br><span class="hljs-comment">// PID增量式算法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PID_Control</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    error = target - current; <span class="hljs-comment">// 计算误差</span><br>    <span class="hljs-type">float</span> delta = Kp * (error - error_1) + Ki * error + Kd * (error - <span class="hljs-number">2</span> * error_1 + error_2);<br>    <span class="hljs-keyword">if</span> (pwmValue &gt; pwmMax) &#123;<br>        pwmValue = pwmMax;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pwmValue &lt; -pwmMax) &#123;<br>        pwmValue = <span class="hljs-number">0</span>;<br>    &#125;<br>    pwmValue += delta;<br>    error_2 = error_1;<br>    error_1 = error;<br>&#125;<br><br><span class="hljs-comment">// PID位置式算法</span><br><span class="hljs-comment">/* void PID_Control(void) &#123; */</span><br><span class="hljs-comment">/*     error = target - current; */</span><br><span class="hljs-comment">/*     integral += error; */</span><br><span class="hljs-comment">/*     if (integral &gt; pwmMax) &#123; */</span><br><span class="hljs-comment">/*         integral = pwmMax; */</span><br><span class="hljs-comment">/*     &#125; else if (integral &lt; -pwmMax) &#123; */</span><br><span class="hljs-comment">/*         integral = -pwmMax; */</span><br><span class="hljs-comment">/*     &#125; */</span><br><span class="hljs-comment">/*     derivative = error - lastError; */</span><br><span class="hljs-comment">/*     pwmValue = Kp * error + Ki * integral + Kd * derivative; */</span><br><span class="hljs-comment">/*     if (pwmValue &gt; pwmMax) &#123; */</span><br><span class="hljs-comment">/*         pwmValue = pwmMax; */</span><br><span class="hljs-comment">/*     &#125; else if (pwmValue &lt; -pwmMax) &#123; */</span><br><span class="hljs-comment">/*         pwmValue = 0; */</span><br><span class="hljs-comment">/*     &#125; */</span><br><span class="hljs-comment">/*     lastError = error; */</span><br><span class="hljs-comment">/* &#125; */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式：SPI通信</title>
    <link href="/2023/11/09/SPI/"/>
    <url>/2023/11/09/SPI/</url>
    
    <content type="html"><![CDATA[<h2 id="一.基础">一.基础</h2><p>SCK：Serial Clock</p><p>MOSI: Master out Slave In(DI)</p><p>MISO: Master in Slave out(DO)</p><p>SS: Slave select(CS chip select)</p><p>常用SPI设备：W25Q64 flash存储器；SPI协议OLED；2.4GNRF24L01；microSD</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/SPIimage.png" /></p><p>SS为高电平时，关闭从机MISO电平输出（防止多从机冲突）。</p><p>Mode1:交换一个字节 CPOL(Clock Polarity) = 0空闲状态SCK低电平CPHA（Clock Phase） = 1 SCK奇数沿移出数据，偶数沿移入数据。</p><p>Mode0（应用最多的）:CPHA =0第一个边沿移入（上升沿采样），第二个边沿移出（进行数据变换）</p><p>Mode2:CPOL = 1 CPHA = 0</p><p>Mode3: CPOL = 1CPHA = 1</p><h2 id="二.读写">二.读写</h2><p>指定地址写：0x02+3 byte address（W25Q64 24位寻址）+写入的数据</p><p>指定地址读：0x03+3 byte address（W25Q6424位寻址）+MISO读取数据（MOSI置1输出0xFF）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式：ADC模数转换</title>
    <link href="/2023/11/08/ADC/"/>
    <url>/2023/11/08/ADC/</url>
    
    <content type="html"><![CDATA[<p>Analog 2Data（模拟信号到数字信号）通常使用stm32内置的ADC设备实现，DAC（数模转换）通常使用TIM输出比较得到PWM波形。</p><p>接线：光敏电阻接PA4（模拟输入），实现单通道连续ADC转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADCx ADC1</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">AD_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<br>    <span class="hljs-keyword">if</span> (ADCx == ADC1) &#123;<br>        RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ADCx == ADC2) &#123;<br>        RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE);<br>    &#125;<br><br>    RCC_ADCCLKConfig(RCC_PCLK2_Div6);                <span class="hljs-comment">//设置ADC时钟频率为12MHz</span><br>    GPIO_startUp(GPIOA, GPIO_Pin_4, GPIO_Mode_AIN);  <span class="hljs-comment">//PA0模拟输入</span><br><br>    ADC_RegularChannelConfig(ADCx, ADC_Channel_4, <span class="hljs-number">1</span>, ADC_SampleTime_55Cycles5);<span class="hljs-comment">//ADC1,ADC通道0,第一个转换,采样时间为55.5周期</span><br><br>    ADC_InitTypeDef ADC_InitStructure;<br>    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;<span class="hljs-comment">//连续转换模式</span><br>    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;<br>    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;<span class="hljs-comment">//不使用外部触发转换</span><br>    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;<br>    ADC_InitStructure.ADC_NbrOfChannel = <span class="hljs-number">1</span>;<br>    ADC_InitStructure.ADC_ScanConvMode = DISABLE;<span class="hljs-comment">//关闭扫描模式</span><br>    ADC_Init(ADCx, &amp;ADC_InitStructure);<br><br>    ADC_Cmd(ADCx, ENABLE);<br><br>    <span class="hljs-comment">// ADC设备校准</span><br>    ADC_ResetCalibration(ADCx);<span class="hljs-comment">//复位校准寄存器</span><br>    <span class="hljs-keyword">while</span> (ADC_GetResetCalibrationStatus(ADCx));<br>    ADC_StartCalibration(ADCx);<span class="hljs-comment">//校准ADC1</span><br>    <span class="hljs-keyword">while</span> (ADC_GetCalibrationStatus(ADCx));<span class="hljs-comment">//等待校准完成</span><br>    ADC_SoftwareStartConvCmd(ADCx, ENABLE);<span class="hljs-comment">//使能指定的ADC1的软件转换启动功能</span><br>&#125;<br><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">AD_getValue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">/* while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET); //等待转换结束 */</span><br>    <span class="hljs-keyword">return</span> ADC_GetConversionValue(ADCx);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式：DMA转运</title>
    <link href="/2023/11/08/DMA(Direct%20Memory%20Access)/"/>
    <url>/2023/11/08/DMA(Direct%20Memory%20Access)/</url>
    
    <content type="html"><![CDATA[<h2 id="一.笔记">一.笔记</h2><p>c8t6 DMA1 7个通道</p><table><thead><tr class="header"><th>类型</th><th>起始地址</th><th>存储器</th><th>用途</th></tr></thead><tbody><tr class="odd"><td>ROM</td><td>0x0800 0000</td><td>Flash主闪存 FLASH_BASE</td><td>存储编译后的代码</td></tr><tr class="even"><td></td><td>0x1FFF F000</td><td>系统存储器</td><td>bootloader / download</td></tr><tr class="odd"><td></td><td>0x1FFF F800</td><td>选项字节</td><td>独立于程序代码的配置（WDG,flash读保护，写保护）</td></tr><tr class="even"><td>RAM</td><td>0x2000 0000</td><td>运存SRAM SRAM_BASE</td><td>==电脑的内存</td></tr><tr class="odd"><td></td><td>0x4000 0000</td><td>外设寄存器 PERIPH_BASE</td><td>外设配置</td></tr><tr class="even"><td></td><td>0xE000 0000</td><td>内核外设寄存器</td><td>内核外设配置NVIC Systick</td></tr></tbody></table><p>DMA基本结构图：</p><center><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/DMA103942A2A83620881B1141EA26C1A230.png" /></center><p>1.APB1 APB2的外设可以通过 DMA请求 向DMA发出硬件触发信号（ADC转换完成，串口收到数据时）请求DMA转运数据。</p><p>2.CPU或DMA无法写入 Flash，可以读写SRAM。</p><p>3.不能在DMA开启时写传输计数器，先用DMA_Cmd disable 再 enable。</p><p>4.M2M == 1时软件触发，0时硬件触发。</p><h2 id="二.应用dma数据转运">二.应用DMA数据转运</h2><p>copy dataA[] 2 dataB[]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dmaInit</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> first, <span class="hljs-type">uint32_t</span> second, <span class="hljs-type">uint16_t</span> size)</span> &#123;<br>    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);<span class="hljs-comment">//使能DMA时钟</span><br>    <br>    DMA_InitTypeDef DMA_InitStructure;<br>    DMA_InitStructure.DMA_PeripheralBaseAddr = first;<br>    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte; <span class="hljs-comment">// 外设数据长度为8位</span><br>    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;<span class="hljs-comment">//外设地址自增</span><br>    DMA_InitStructure.DMA_MemoryBaseAddr = second;<br>    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte; <span class="hljs-comment">// 内存数据长度为8位</span><br>    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; <span class="hljs-comment">// 使能内存地址自增</span><br>    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;<span class="hljs-comment">//数据传输方向，Periph -&gt; Memory</span><br>    DMA_InitStructure.DMA_BufferSize = size;<span class="hljs-comment">//传输计数器</span><br>    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal; <span class="hljs-comment">// 正常模式,不自动重装</span><br>    DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; <span class="hljs-comment">// 中等优先级</span><br>    DMA_InitStructure.DMA_M2M = DMA_M2M_Enable; <span class="hljs-comment">// 禁止内存到内存传输</span><br>    DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);<br><br>    DMA_Cmd(DMA1_Channel1, ENABLE);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三.adc扫描模式dma">三.ADC扫描模式+DMA</h2><p>ADC扫描模式有数据覆盖的特性ADC_DR寄存器，配合DMA进行数据转运。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式：MPU6050陀螺仪</title>
    <link href="/2023/11/02/Week4%20MPU6050%E9%99%80%E8%9E%BA%E4%BB%AA/"/>
    <url>/2023/11/02/Week4%20MPU6050%E9%99%80%E8%9E%BA%E4%BB%AA/</url>
    
    <content type="html"><![CDATA[<h2 id="一.mpu读取pitch通过串口输出">一.mpu读取pitch通过串口输出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">float</span> pitch, roll, yaw;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<br>    Serial_Init(<span class="hljs-number">9600</span>); <span class="hljs-comment">//串口初始化，波特率9600</span><br>    MPU_Init();<span class="hljs-comment">//陀螺仪初始化</span><br>    mpu_dmp_init();<br>    LED_Init(GPIOC, GPIO_Pin_13);<span class="hljs-comment">//初始化PC13小灯</span><br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mpu_dmp_get_data(&amp;pitch, &amp;roll, &amp;yaw) == <span class="hljs-number">0</span>) &#123;<br>            LED_Switch(GPIOC, GPIO_Pin_13);<br>            <span class="hljs-comment">// 如果正常得到mpu6050数据 切换小灯状态</span><br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %.3f \r\n&quot;</span>, pitch);<span class="hljs-comment">// 串口输出</span><br>        Delay_ms(<span class="hljs-number">50</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href=""><imgsrc="https://gw.alipayobjects.com/mdn/prod_resou/afts/img/A*NNs6TKOR3isAAAAAAAAAAABkARQnAQ"alt="5033848b41d50b9b450170bba370e446.mp4 (2.94MB)" /></a><ahref="https://www.yuque.com/attachments/yuque/0/2023/zip/39043553/1698922853602-f26bf8d2-67b6-4749-adaa-c7d2266a0da1.zip?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fzip%2F39043553%2F1698922853602-f26bf8d2-67b6-4749-adaa-c7d2266a0da1.zip%22%2C%22name%22%3A%22stm32Projectsp1.zip%22%2C%22size%22%3A10792428%2C%22ext%22%3A%22zip%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22uf03b097b-91dd-422c-ba45-9e707a0accf%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fx-zip-compressed%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22ua09ddbcd%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">stm32Projectsp1.zip</a>## 二.平均值滤波 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;filter.h&quot;</span></span><br><br><span class="hljs-comment">//初始化，把filter清零</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">AverFilter_Init</span><span class="hljs-params">(AverFilter *filter)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; WINDOW_SIZE; i++) &#123;<br>        filter-&gt;data[i] = <span class="hljs-number">0.0</span>;<br>    &#125;<br>    filter-&gt;pivot = <span class="hljs-number">0</span>;<br>    filter-&gt;count = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//添加一个数据到数据缓冲区</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">AverFilter_AddData</span><span class="hljs-params">(AverFilter *filter, <span class="hljs-type">float</span> data)</span> &#123;<br>    filter-&gt;data[filter-&gt;pivot] = data;<br>    filter-&gt;pivot = (filter-&gt;pivot + <span class="hljs-number">1</span>) % WINDOW_SIZE; <span class="hljs-comment">//循环数据缓冲区</span><br>    <span class="hljs-keyword">if</span> (filter-&gt;count &lt; WINDOW_SIZE) &#123;<br>        filter-&gt;count++;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//求和并求平均值</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">AverFilter_GetResult</span><span class="hljs-params">(AverFilter *filter)</span> &#123;<br>    <span class="hljs-type">float</span> sum = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; filter-&gt;count; i++) &#123;<br>        sum += filter-&gt;data[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum / filter-&gt;count;<br>&#125;<br><br></code></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __FILTER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __FILTER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WINDOW_SIZE 5 <span class="hljs-comment">// 求平均值时一组数据的个数</span></span><br><br><span class="hljs-comment">//AverFilter结构体，data[]为数据缓冲区，pivot指针，count为个数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">float</span> data[WINDOW_SIZE];<br>    <span class="hljs-type">uint8_t</span> pivot;<br>    <span class="hljs-type">uint8_t</span> count;<br><br>&#125; AverFilter;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">AverFilter_Init</span><span class="hljs-params">(AverFilter *filter)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">AverFilter_AddData</span><span class="hljs-params">(AverFilter *filter, <span class="hljs-type">float</span> data)</span>;<br><span class="hljs-type">float</span> <span class="hljs-title function_">AverFilter_GetResult</span><span class="hljs-params">(AverFilter *filter)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure> <a href=""><imgsrc="https://gw.alipayobjects.com/mdn/prod_resou/afts/img/A*NNs6TKOR3isAAAAAAAAAAABkARQnAQ"alt="31bef6d0b0c64834275030f573f8ad1c.mp4 (4.3MB)" /></a><ahref="https://www.yuque.com/attachments/yuque/0/2023/zip/39043553/1698922853839-08a3a415-b9eb-4bc2-98a6-fc1c6ff9af9c.zip">stm32Projectsp2.zip</a>## 三.OLED显示pitch数据 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> pitch, roll, yaw;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<br>    Serial_Init(<span class="hljs-number">9600</span>); <span class="hljs-comment">//串口初始化，波特率9600</span><br>    MPU_Init();<br>    mpu_dmp_init();<br>    LED_Init(GPIOC, GPIO_Pin_13); <span class="hljs-comment">//初始化PC13小灯</span><br><br>    <span class="hljs-comment">// 初始化OLED</span><br>    OLED_Init();<br>    OLED_ColorTurn(<span class="hljs-number">0</span>);<br>    OLED_DisplayTurn(<span class="hljs-number">1</span>);<br>    OLED_ShowString(<span class="hljs-number">70</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;pitch&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);<br>    OLED_Refresh();<br><br>    <span class="hljs-type">char</span> res[<span class="hljs-number">10</span>]; <span class="hljs-comment">//res字符串接受pitch数据</span><br><br>    AverFilter pitchFilter;<br>    AverFilter_Init(&amp;pitchFilter);<span class="hljs-comment">//初始化平均值滤波</span><br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; WINDOW_SIZE; i++) &#123;<br>            <span class="hljs-keyword">if</span> (mpu_dmp_get_data(&amp;pitch, &amp;roll, &amp;yaw) == <span class="hljs-number">0</span>) &#123;<br>                LED_Switch(GPIOC, GPIO_Pin_13);<br>                <span class="hljs-comment">// 如果正常得到陀螺仪数据，切换小灯状态</span><br>            &#125;<br>            AverFilter_AddData(&amp;pitchFilter, pitch);<span class="hljs-comment">//添加pitch到data[]中</span><br>            Delay_ms(<span class="hljs-number">10</span>);<br>        &#125;<br>        <span class="hljs-built_in">sprintf</span>(res, <span class="hljs-string">&quot; %.3f&quot;</span>, AverFilter_GetResult(&amp;pitchFilter)); <span class="hljs-comment">// sprintf函数用于把浮点转为char[]保留三位小数</span><br><br>        OLED_ShowString(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, res, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//打印平均值滤波后的pitch数据</span><br>        OLED_Refresh();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure> <a href=""><imgsrc="https://gw.alipayobjects.com/mdn/prod_resou/afts/img/A*NNs6TKOR3isAAAAAAAAAAABkARQnAQ"alt="4a36b286086c4ad3eddea0b12f84aced.mp4 (7.72MB)" /></a><ahref="https://www.yuque.com/attachments/yuque/0/2023/zip/39043553/1698922854047-ee8498ea-d342-4008-9c15-fec3faec2e8a.zip">stm32Projectsp3.zip</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式：TIM定时器</title>
    <link href="/2023/10/09/Week3%20TIM%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88%E5%91%BC%E5%90%B8%E7%81%AF%EF%BC%8C%E8%88%B5%E6%9C%BA%EF%BC%8C%E8%B6%85%E5%A3%B0%E6%B3%A2%EF%BC%89/"/>
    <url>/2023/10/09/Week3%20TIM%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88%E5%91%BC%E5%90%B8%E7%81%AF%EF%BC%8C%E8%88%B5%E6%9C%BA%EF%BC%8C%E8%B6%85%E5%A3%B0%E6%B3%A2%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一.呼吸灯">一.呼吸灯</h2><h6 id="代码">1.代码</h6><p>直接用了舵机的代码，在main中循环调节CCR寄存器 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;oled.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pwm.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;IC.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;key.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<br>OLED_Init();<br>OLED_ColorTurn(<span class="hljs-number">0</span>);<br>OLED_DisplayTurn(<span class="hljs-number">1</span>);<br><br>PWM_Init();<br><span class="hljs-comment">// IC_Init();</span><br><span class="hljs-comment">// key_Init();</span><br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 第二行显示 TIM2 计时器</span><br><span class="hljs-comment">// OLED_ShowNum(1, 16, TIM_GetCounter(TIM2), 6, 16, 1);</span><br><span class="hljs-comment">// OLED_Refresh();</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>PWM_setCompare1(i);<br>Delay_ms(<span class="hljs-number">10</span>);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>PWM_setCompare1(<span class="hljs-number">100</span> - i);<br>Delay_ms(<span class="hljs-number">10</span>);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PWM_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<br><br>    GPIO_startUp(GPIOA, GPIO_Pin_0, GPIO_Mode_AF_PP);<br><br>    Timer_Init(TIM2, <span class="hljs-number">20000</span> - <span class="hljs-number">1</span>, <span class="hljs-number">72</span> - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// TIM O(utput) C(Compare) 输出比较初始化</span><br>    TIM_OCInitTypeDef TIM_OCInitStructure;<br>    TIM_OCStructInit(&amp;TIM_OCInitStructure);<br>    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;<br>    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;<br>    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;<br>    TIM_OCInitStructure.TIM_Pulse = <span class="hljs-number">500</span>;              <span class="hljs-comment">// CCR</span><br>    TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);<br><br>    TIM_Cmd(TIM2, ENABLE);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PWM_setCompare1</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> cmp)</span> &#123;<br><br>    TIM_SetCompare1(TIM2, cmp);<br>&#125;<br><br><span class="hljs-comment">// 设置 PSC -&gt; PWM 频率</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PWM_setPrescaler</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> prescaler)</span> &#123;<br>    TIM_PrescalerConfig(TIM2, prescaler, TIM_PSCReloadMode_Update);<br>&#125;<br></code></pre></td></tr></table></figure> ###### 2.演示视频 <ahref="!%5B%5D(https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/week3image.png)"><imgsrc="" alt="701ffb9687b5dce5ecb368f23a32d10b.mp4 (864.09KB)" /></a> ##二.舵机驱动 ###### 1.代码 (1)360舵机<br />舵机周期 20ms 50Hz<br />CK_PSC / (ARR + 1) / (PSC + 1) = 50 ARR + 1 = 20000 PSC + 1 =72<br />f = CK_PSC / (PSC + 1) = 1MHz T = 1 / 1M = 10^3ms<br />经测试CCR顺时针有效值: 414 ~ 1460 对应 0.414ms ~ 1.46ms 占空比:2.07% ~ 7.3%<br /> 逆时针有效值：1528 ~ 2573 1.528ms ~ 2.573ms占空比：7.64% ~ 12.865% <br />离 1.5ms越远转速越快?<br />(2)180舵机<br /> <imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/week3image.png" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PWM_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<br><br>    GPIO_startUp(GPIOA, GPIO_Pin_0, GPIO_Mode_AF_PP);<br><br>    Timer_Init(TIM2, <span class="hljs-number">20000</span> - <span class="hljs-number">1</span>, <span class="hljs-number">72</span> - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// TIM OC 输出捕获初始化</span><br>    TIM_OCInitTypeDef TIM_OCInitStructure;<br>    TIM_OCStructInit(&amp;TIM_OCInitStructure);<br>    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;<br>    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;<br>    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;<br>    TIM_OCInitStructure.TIM_Pulse = <span class="hljs-number">500</span>;              <span class="hljs-comment">// CCR</span><br>    TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);<br><br>    TIM_Cmd(TIM2, ENABLE);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PWM_setCompare1</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> cmp)</span> &#123;<br><br>    TIM_SetCompare1(TIM2, cmp);<br>&#125;<br><br><span class="hljs-comment">// 设置 PSC -&gt; PWM 频率</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PWM_setPrescaler</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> prescaler)</span> &#123;<br>    TIM_PrescalerConfig(TIM2, prescaler, TIM_PSCReloadMode_Update);<br>&#125;<br></code></pre></td></tr></table></figure> ###### 2.演示视频 <a href=""><imgsrc="https://gw.alipayobjects.com/mdn/prod_resou/afts/img/A*NNs6TKOR3isAAAAAAAAAAABkARQnAQ"alt="8954ffc9eafc0c1970fb15a2d82a98eb.mp4 (322.14KB)" /></a>##三.超声波测距 实现按一下按键在oled第一行打印距离(cm) ###### 1.核心代码startTime记录 CCR1 endTime记录 CCR2，通过时间差得到距离。captured相等于一个标志 =0等待捕获上升，= 1等待捕获下降。<br />Timer_InitNVIC_startup GPIO_startup在general.c中写好的函数，方便调用。<br />主要学习了 TIM_PWMIConfig()函数，它可配置两个通道捕获一个 GPIO引脚（echo），看了定义发现就是把所有取反比如falling -&gt; rising，direct-&gt; inDirect配置给另外一个通道。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span> startTime = <span class="hljs-number">0</span>, endTime = <span class="hljs-number">0</span>;<br><span class="hljs-type">uint8_t</span> captured = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">IC_trigger</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 将Trig引脚设置为低电平</span><br>    GPIO_ResetBits(GPIOB, GPIO_Pin_5);<br>    Delay_us(<span class="hljs-number">2</span>); <span class="hljs-comment">// 短暂延时</span><br><br>    <span class="hljs-comment">// 生成一个高电平脉冲</span><br>    GPIO_SetBits(GPIOB, GPIO_Pin_5);<br>    Delay_us(<span class="hljs-number">20</span>);<br><br>    <span class="hljs-comment">// 再次将Trig引脚设置为低电平</span><br>    GPIO_ResetBits(GPIOB, GPIO_Pin_5);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">IC_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);<br><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<br>    GPIO_startUp(GPIOA, GPIO_Pin_0, GPIO_Mode_IN_FLOATING); <span class="hljs-comment">// 配置echo引脚 浮空输入</span><br><br>    Timer_Init(TIM2, <span class="hljs-number">65536</span> - <span class="hljs-number">1</span>, <span class="hljs-number">7200</span> - <span class="hljs-number">1</span>); <span class="hljs-comment">// Timer_Init(TIMx, period, preScaler)</span><br><br>    TIM_ICInitTypeDef TIM_ICInitStructure;<br>    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;<br>    TIM_ICInitStructure.TIM_ICFilter = <span class="hljs-number">0xF</span>;<br>    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;<br>    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;<br>    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;<br>    TIM_PWMIConfig(TIM2, &amp;TIM_ICInitStructure);<br><br>    <span class="hljs-comment">// 通道1捕捉上升沿，通道2捕捉下降沿</span><br>    TIM_ITConfig(TIM2, TIM_IT_CC1, ENABLE);<br>    TIM_ITConfig(TIM2, TIM_IT_CC2, ENABLE);<br>    NVIC_startUp(TIM2_IRQn, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    TIM_Cmd(TIM2, ENABLE);<br>&#125;<br><br><span class="hljs-comment">// 超声波中断函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">TIM2_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span>(TIM_GetITStatus(TIM2, TIM_IT_CC1) == SET) &#123;<br>        <span class="hljs-keyword">if</span>(captured == <span class="hljs-number">0</span>) &#123;<br>            startTime = TIM_GetCapture1(TIM2);<br>            captured = <span class="hljs-number">1</span>;<br>        &#125;<br>        TIM_ClearITPendingBit(TIM2, TIM_IT_CC1);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_CC2) == SET) &#123;<br>        <span class="hljs-keyword">if</span> (captured == <span class="hljs-number">1</span>) &#123;<br>            endTime = TIM_GetCapture2(TIM2);<br><br>            <span class="hljs-keyword">if</span> (endTime &gt;= startTime) &#123;<br>                <span class="hljs-comment">// 加上判断防止出现 start 和 end 之间计数器溢出的情况</span><br>                <span class="hljs-type">uint32_t</span> delta = endTime - startTime;<br>                <span class="hljs-type">float</span> distance = (<span class="hljs-type">float</span>)delta * <span class="hljs-number">3.43</span> / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 72MHz / 7200 = 10^4Hz delta单位是 10^-4 s</span><br>                <span class="hljs-type">char</span> s[<span class="hljs-number">10</span>];<br>                <span class="hljs-built_in">sprintf</span>(s, <span class="hljs-string">&quot;%.3f&quot;</span>, distance);              <span class="hljs-comment">// float2string </span><br>                OLED_ShowString(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, s, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);<br>                OLED_Refresh();<br>            &#125;<br>            captured = <span class="hljs-number">0</span>;<br>        &#125;<br>            <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 按键中断调用IC_trigger() <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">key_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);<br>GPIO_startUp(GPIOB, GPIO_Pin_15, GPIO_Mode_IPD); <span class="hljs-comment">// PB15接按键 OUT</span><br>GPIO_startUp(GPIOB, GPIO_Pin_5, GPIO_Mode_Out_PP);       <span class="hljs-comment">// PB5 接超声波 trig</span><br><br>GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource15);<br><span class="hljs-comment">//配置 EXTI 外部中断</span><br>EXTI_InitTypeDef EXTI_InitStructure;<br>EXTI_InitStructure.EXTI_Line = EXTI_Line15;<br>EXTI_InitStructure.EXTI_LineCmd = ENABLE;<br>EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;<br>EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;<br><br>EXTI_Init(&amp;EXTI_InitStructure);<br>NVIC_startUp(EXTI15_10_IRQn, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI15_10_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-keyword">if</span>(EXTI_GetITStatus(EXTI_Line15) == SET) &#123;<br>        Delay_ms(<span class="hljs-number">20</span>); <span class="hljs-comment">// 消抖</span><br>        <span class="hljs-keyword">if</span>(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_15)) &#123;<br>            IC_trigger();<br>        &#125;<br>        EXTI_ClearITPendingBit(EXTI_Line15);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;oled.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pwm.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;IC.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;key.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); <span class="hljs-comment">// 配置NIVC优先级分组模式</span><br>OLED_Init();<br>OLED_ColorTurn(<span class="hljs-number">0</span>);<br>OLED_DisplayTurn(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// PWM_Init();</span><br>IC_Init();<br>key_Init();<br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 第二行显示 TIM2 计时器</span><br>OLED_ShowNum(<span class="hljs-number">1</span>, <span class="hljs-number">16</span>, TIM_GetCounter(TIM2), <span class="hljs-number">6</span>, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);<br>OLED_Refresh();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure> ###### 2.演示视频 <ahref=""><imgsrc="https://gw.alipayobjects.com/mdn/prod_resou/afts/img/A*NNs6TKOR3isAAAAAAAAAAABkARQnAQ"alt="152daad5860ce566c6cb966a325d4093.mp4 (4.06MB)" /></a>## 四.项目文件<ahref="https://www.yuque.com/attachments/yuque/0/2023/zip/39043553/1697622338744-a22dd6ec-0945-4985-8881-09d0f2db55ec.zip">stm32Projects3.zip</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式：UART串口通信</title>
    <link href="/2023/09/30/Week2%20USART%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
    <url>/2023/09/30/Week2%20USART%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="一.实现效果">一.实现效果</h2><p>AA包头 C6 FF包尾 可变包长hex数据包<br />a.串口点灯 只有发送 AA 20 50AB C6 FF指令点灯，OLED打印"Led on"，指令不合法则打印"ERROR"<br />b.蓝牙电灯效果同上<br />c.蓝牙接收数据包，再发送回上位机 ## 二.代码注释1.串口代码在 Serial.c 和 Serial.h 中 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __SERIAL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SERIAL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> pivot;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Serial_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Serial_SendByte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> byte)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Serial_SendArray</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *<span class="hljs-built_in">array</span>, <span class="hljs-type">uint16_t</span> length)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Serial_SendString</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Serial_SendPacket</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *packet)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Serial_Printf</span><span class="hljs-params">(<span class="hljs-type">char</span> *format, ...)</span>;<br><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">Serial_ReadByte</span><span class="hljs-params">(USART_TypeDef *USARTx)</span>;<br><br><span class="hljs-type">uint8_t</span>* <span class="hljs-title function_">getRxPacket</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">getRxFlag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEN 256</span><br><br><span class="hljs-type">uint8_t</span> pivot = <span class="hljs-number">0</span>;<br><span class="hljs-type">uint8_t</span> Serial_RxPacket[LEN];<br><span class="hljs-type">uint8_t</span> RxFlag; <span class="hljs-comment">// 接受到数据标志</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Serial_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<span class="hljs-comment">// USART3 对应 PB10 TX PB11 RX</span><br><br>GPIO_InitTypeDef GPIO_InitStructure;<br><span class="hljs-comment">// 初始化 TX</span><br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class="hljs-comment">// 复用推挽输出</span><br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<br><br><span class="hljs-comment">//初始化 RX</span><br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="hljs-comment">// 上拉输入</span><br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<br><br>USART_InitTypeDef USART_InitStructure;<br>USART_InitStructure.USART_BaudRate = <span class="hljs-number">9600</span>;<br>USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<br>USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;<br>USART_InitStructure.USART_Parity = USART_Parity_No; <span class="hljs-comment">// 无校验</span><br>USART_InitStructure.USART_StopBits = USART_StopBits_1; <span class="hljs-comment">// 停止位长度</span><br>USART_InitStructure.USART_WordLength = USART_WordLength_8b;<br>USART_Init(USART3, &amp;USART_InitStructure);<br><br><span class="hljs-comment">// 配置中断</span><br>USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);<br>NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<br>NVIC_InitTypeDef NVIC_InitStructure;<br>NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;<br>NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<br>NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number">1</span>;<br>NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="hljs-number">1</span>;<br>NVIC_Init(&amp;NVIC_InitStructure);<br><br><span class="hljs-comment">// 启用 USART3</span><br>USART_Cmd(USART3, ENABLE);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Serial_SendByte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> byte)</span> &#123;<br><br>USART_SendData(USART3, byte);<br><span class="hljs-keyword">while</span>(USART_GetFlagStatus(USART3, USART_FLAG_TXE) == RESET);<br><br>&#125;<br><br><span class="hljs-comment">// while查询 接受数据</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">Serial_ReadByte</span><span class="hljs-params">(USART_TypeDef *USARTx)</span> &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span> (USART_GetFlagStatus(USART3, USART_FLAG_RXNE) == SET)&#123;<br><span class="hljs-keyword">return</span> USART_ReceiveData(USART3);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 发送数组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Serial_SendArray</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *<span class="hljs-built_in">array</span>, <span class="hljs-type">uint16_t</span> length)</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>Serial_SendByte(<span class="hljs-built_in">array</span>[i]);<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Serial_SendString</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>)</span> &#123;<br><span class="hljs-comment">// string 以 0x00 结尾，存储空间=字符个数 + 1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint8_t</span> i = <span class="hljs-number">0</span>; <span class="hljs-built_in">string</span>[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++) &#123;<br>Serial_SendByte(<span class="hljs-built_in">string</span>[i]);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 重定向 printf</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> &#123;<br>Serial_SendByte(ch);<br><span class="hljs-keyword">return</span> ch;<br>&#125;<br><br><span class="hljs-comment">// 传 接受数据包指针</span><br><span class="hljs-type">uint8_t</span>* <span class="hljs-title function_">getRxPacket</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-keyword">return</span> Serial_RxPacket;<br>&#125;<br><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">getRxFlag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (RxFlag == <span class="hljs-number">1</span>) &#123;<br>RxFlag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 中断函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">USART3_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> RxState = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (USART_GetITStatus(USART3, USART_IT_RXNE) == SET) &#123;<br><span class="hljs-type">uint8_t</span> RxData = USART_ReceiveData(USART3);<br><br><span class="hljs-keyword">if</span>(RxState == <span class="hljs-number">0</span> &amp;&amp; RxData == <span class="hljs-number">0xAA</span>) &#123;<br>RxState = <span class="hljs-number">1</span>;<br>pivot = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (RxState == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span>(RxData == <span class="hljs-number">0xC6</span>) &#123;<br>RxState = <span class="hljs-number">2</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Serial_RxPacket[pivot] = RxData;<br>pivot++;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (RxState == <span class="hljs-number">2</span> &amp;&amp; RxData == <span class="hljs-number">0xFF</span>) &#123;<br>RxState = <span class="hljs-number">0</span>;<br>RxFlag = <span class="hljs-number">1</span>;<br>&#125;<br><br>USART_ClearITPendingBit(USART3, USART_IT_RXNE);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 发送可变包长HEX数据包 AA包头 C6 FF包尾</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Serial_SendPacket</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *packet)</span> &#123;<br>Serial_SendByte(<span class="hljs-number">0xAA</span>);<br>Serial_SendArray(packet, pivot);<br>Serial_SendByte(<span class="hljs-number">0xC6</span>);<br>Serial_SendByte(<span class="hljs-number">0xFF</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>当出发USART_IT_RXNE中断时进入中断函数接受数据包<br />我用pivot作为接受数组的索引，Rxstate变量保存当前状态:stage0:接受包头如果接受 0xAA转移到stage1，开始接受数据并监听0xC6，如果是则进入stage2.（用switchcase好像不行？）<br />uint16_t Serial_ReadByte(USART_TypeDef *USARTx)这个函数忽略 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> cmdPacket[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0x20</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0xAB</span>&#125;;<br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (getRxFlag() == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-type">uint8_t</span> *p = getRxPacket();<br><span class="hljs-keyword">if</span> (pivot == <span class="hljs-number">3</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (p[i] != cmdPacket[i]) &#123;<br>OLED_Clear();<br>OLED_ShowString(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;ERROR&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);<br>OLED_Refresh();<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) &#123;<br>LED_Switch(GPIOB, GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14);<br><span class="hljs-keyword">if</span> (GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_12) == RESET) &#123;<br>OLED_Clear();<br>OLED_ShowString(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;LED on&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);<br>OLED_Refresh();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>OLED_Clear();<br>OLED_ShowString(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;LED off&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);<br>OLED_Refresh();<br>&#125;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>OLED_Clear();<br>OLED_ShowString(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;ERROR&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);<br>OLED_Refresh();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>这是验证指令代码，写的比较丑（应该封装一下）我想实现验证数据包点亮小灯，验证pivot== 3（0:0x20 1:0x50 2:0xAB添加完 0xAB后又pivot++=3）数据长度是前提，每次for循环前验证RxPacket和cmd_packet，如果第2位0xAB还没有被break掉说明验证通过。## 三.演示视频 a. <a href=""><imgsrc="https://gw.alipayobjects.com/mdn/prod_resou/afts/img/A*NNs6TKOR3isAAAAAAAAAAABkARQnAQ"alt="691461ea29c2b1475cffe7a93228423c.mp4 (9.68MB)" /></a>b. <ahref=""><imgsrc="https://gw.alipayobjects.com/mdn/prod_resou/afts/img/A*NNs6TKOR3isAAAAAAAAAAABkARQnAQ"alt="47919cb39dabaccd0c7269911d2b8731.mp4 (5.16MB)" /></a>c. <ahref=""><imgsrc="https://gw.alipayobjects.com/mdn/prod_resou/afts/img/A*NNs6TKOR3isAAAAAAAAAAABkARQnAQ"alt="2c6aa9966e47b381ba7d961d391b3e0c.mp4 (3.79MB)" /></a> ##四.工程文件 <ahref="https://www.yuque.com/attachments/yuque/0/2023/zip/39043553/1698922745761-153042a6-f69f-45f6-9283-14e38826267b.zip">stm32Projects930.zip</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式：GPIO点亮小灯</title>
    <link href="/2023/09/24/Week1%20%E7%82%B9%E4%BA%AE%E5%B0%8F%E7%81%AF%20GPIO/"/>
    <url>/2023/09/24/Week1%20%E7%82%B9%E4%BA%AE%E5%B0%8F%E7%81%AF%20GPIO/</url>
    
    <content type="html"><![CDATA[<h2 id="一实现效果">一、实现效果</h2><p>a.在Delay.c中实现SysTick定时器<br />点亮小灯，每2s闪烁<br />b.按键切换小灯(监听高电平信号，GPIO下拉输入)<br />## 二、心得体会</p><table><thead><tr class="header"><th></th><th>寄存器</th><th></th><th></th></tr></thead><tbody><tr class="odd"><td>1</td><td>CTRL</td><td>IO</td><td>Systick 控制及状态</td></tr><tr class="even"><td>2</td><td>VAL</td><td>IO</td><td>当前值寄存器</td></tr><tr class="odd"><td>3</td><td>LOAD</td><td>IO</td><td>重装载寄存器</td></tr></tbody></table><p>1.CTRL=0x00000005 = 101 <br />bit0: ENABLE 1 enable 0disable<br />bit1: TICKINT 1 溢出中断 0 溢出不中断<br />bit2: CLKSOURCE1 HCLK 0 HCLK_Div8<br />bit16: COUNTFLAG 如果在上次读取本寄存器后，SysTick 已经计到 了 0，则该位为 1。<br />while(!(SysTick-&gt;CTRL &amp;0x00010000)); 按位与仅当COUNTFLAG为1时终止while<br />2.VAL当前计数值<br />3.LOAD寄存器定时器重装值 72(MHz时钟频率) * us(microsecond)<br /> ## 三、演示视频：a. <a href=""><imgsrc="https://gw.alipayobjects.com/mdn/prod_resou/afts/img/A*NNs6TKOR3isAAAAAAAAAAABkARQnAQ"alt="record.mp4 (4.59MB)" /></a>b. <a href=""><imgsrc="https://gw.alipayobjects.com/mdn/prod_resou/afts/img/A*NNs6TKOR3isAAAAAAAAAAABkARQnAQ"alt="2.mp4 (2.23MB)" /></a>四、项目文件：<br /><ahref="https://www.yuque.com/attachments/yuque/0/2023/zip/39043553/1695379886759-4c771a32-b48a-4a4f-bdb2-a1e2ff16094e.zip">stm32Project924.zip</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>赶紧上车：Big Sur更换DW1820A网卡</title>
    <link href="/2021/08/14/DW1820A/"/>
    <url>/2021/08/14/DW1820A/</url>
    
    <content type="html"><![CDATA[<p>大概两三年前，我开始接触黑苹果。当时使用黑果小兵的安装盘在我的老台式机上安装i5-4590+ geforcegt740，一遍成功，没有做任何调试。当屏幕第一次点亮，蔚蓝的天空映衬着广袤无际的Mojave 沙漠，我真正被 macOS的精美设计甚至说是一种艺术的情怀所折服。随后由于中考很长时间没有碰macOS，20年寒假，买了个轻薄本，经过几个月的折腾后重新吃上了Catalina。</p><p>去年 WWDC 发布上全新的 MacBook Pro 搭载了 M1芯片，我非常兴奋，但心底却有一丝顾忌和遗憾：Intel平台处理器或许在几年之内就不受支持了，黑苹果也将寿终正寝了，且用且珍惜吧。</p><p><del>没两天苹果又发布了最新款21年 iPad Pro，同时搭载了自家的 M1芯片，你的下一台电脑何必是电脑呢？（苹果NB, yyds!）</del></p><p><em><del>牙膏厂：WDNMD， 姓 A 的没一个好东西</del></em></p><hr /><p>进入正题，今天开始着手写一些关于 Hackintosh 的文章。</p><p>目前我的黑苹果主力机是这台笔记本：i5-10210u 8 + 512。原装网卡是 IntelAC 9462，原来 Catalina 采用的是 Airportitlwm 驱动，升级到 Big Sur 11.2.3后网络就无法使用了，Intel 网卡不支持 Airdrop，Handoff体验本来就差，现在又要折腾。斟酌了一会，便狠心在某宝上160 RMB 剁了张 DW1820A。</p><p>拆壳，断电，换卡，上盖一套搞定：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/DW1820A01.jpeg" /></p><p>DW1820A 有两版本，具体型号如下（摘自黑果小兵）：</p><p>Dell 版 <strong>DW1820A</strong></p><table><thead><tr class="header"><th style="text-align: left;">Part Number</th><th style="text-align: left;">Manufacturer</th><th style="text-align: left;">Module</th><th style="text-align: left;">WLAN</th><th style="text-align: left;">BT 4.1</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">CN-0VW3T3</td><td style="text-align: left;">Dell Wireless 1820A 802.11ac</td><td style="text-align: left;">BCM94350ZAE_2</td><td style="text-align: left;">1028:0021</td><td style="text-align: left;">[0a5c:6412]</td></tr><tr class="even"><td style="text-align: left;">CN-0VW3T3</td><td style="text-align: left;">Dell Wireless 1820A 802.11ac</td><td style="text-align: left;">BCM94356ZEPA50DX_2</td><td style="text-align: left;">1028:0021</td><td style="text-align: left;">[0a5c:6412]</td></tr><tr class="odd"><td style="text-align: left;">CN-096JNT</td><td style="text-align: left;">Dell Wireless 1820A 802.11ac</td><td style="text-align: left;">BCM94356ZEPA50DX_2</td><td style="text-align: left;">1028:0022</td><td style="text-align: left;">[0a5c:6412]</td></tr><tr class="even"><td style="text-align: left;">CN-08PKF4</td><td style="text-align: left;">Dell Wireless 1820A 802.11ac</td><td style="text-align: left;">BCM94356ZEPA50DX_2</td><td style="text-align: left;">1028:0023</td><td style="text-align: left;">[0a5c:6412]</td></tr></tbody></table><p>联想版 <strong>BCM94350</strong></p><table><thead><tr class="header"><th style="text-align: left;">Part Number</th><th style="text-align: left;">Manufacturer</th><th style="text-align: left;">Module</th><th style="text-align: left;">WLAN</th><th style="text-align: left;">BT 4.1</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">00JT493</td><td style="text-align: left;">Lenovo</td><td style="text-align: left;">BCM94350ZAE_2</td><td style="text-align: left;">1028:075a</td><td style="text-align: left;">[0a5c:6414]</td></tr><tr class="even"><td style="text-align: left;">00JT494</td><td style="text-align: left;">Lenovo</td><td style="text-align: left;">BCM94350ZAE_2</td><td style="text-align: left;">1028:075a</td><td style="text-align: left;">[0a5c:6414]</td></tr></tbody></table><p>建议优先选择戴尔 CN-0VW3T3 和 CN-08PKF4两种料号。并且联想及绝大多数机型需要屏蔽针脚（我的机子不需要屏蔽，11和12针镊子胶带裹一下，老鸟直接扣金手指都行）。</p><p>一共需要四个内核拓展：AirportBrcmFixup，BrcmBluetoothInjector，BrcmFirmwareData和 BrcmPatchRAM3。其中第一个是 WIFI 驱动，后三是蓝牙驱动，将信息填入config.plist -&gt; kernel -&gt; Add 路径中，但有两点要注意：</p><ul><li>操作前把 EFI 文件中其他的网卡驱动彻底删除，如 Airportitlwm</li><li>拆包 AirportBrcmFixup 后你会发现集成了两卫星插件 AirPortBrcm4360 和AirPortBrcmNIC_Injector，Big Sur 用户请移除4360，否则会造成无法开机！（11.5.7及更低版本保留。苹果从 11 版本开始加载IOFamily80211 和 AirPortBrcm4360 内核拓展，强制用 OC 加载会导致 KernelPanic）</li></ul><p>完成如下图：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/DW1820A02.png" /></p><p>重启后不出意外就能打开 WIFI 和蓝牙了，Airdrop Handoff也能正常使用。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/DW1820A03.png" /></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>macOS下编译Lean的Openwrt源码</title>
    <link href="/2021/08/14/Openwrt/"/>
    <url>/2021/08/14/Openwrt/</url>
    
    <content type="html"><![CDATA[<p>虽然说是用 macOS 系统，但是像编译这种工作搭建个 Docker环境其实是一劳永逸的。请创建 Ubuntu18.04LTS或20.4的容器，可以使用MacPorts 进行安装，具体方法不再赘述。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Openwrt02.png" /></p><p>Lean 大在他的源码仓库中明确支持不要使用 root用户进行编译，按照他所讲的，我们创建一个普通用户，并在 /etc/sudoers 中给root 权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">root&amp;&gt; useradd free<br>root&amp;&gt; passwd free<br><br>root&amp;&gt; <span class="hljs-built_in">mkdir</span> /home/free &amp;&amp; <span class="hljs-built_in">chown</span> -R free /home/free <br>root&amp;&gt; vim /etc/sudoers // 别忘了 wq!<br><br>root&amp;&gt; su free<br></code></pre></td></tr></table></figure><p>我们现在已经以 free用户的身份在home目录，如果你没有一个稳定的上网环境还需要把 apt 的sourcelist 改成国内源。sudo apt update 之后安装编译所需的基本工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get -y install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev libz-dev patch python3 python2.7 unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf automake libtool autopoint device-tree-compiler g++-multilib antlr3 gperf wget curl swig rsync<br></code></pre></td></tr></table></figure><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Openwrt01.png" /></p><p>接着使用 git clone https://github.com/coolsnowwolf/lede.git 把源码clone 到本地，然后 cd lede 进入目录。</p><p>默认的固件源码相对来说过于干净，没有乱七八糟的东西。如果想预编译其他的插件，如Passwall SSRplus 等等，就需要第三方 packages。推荐使用 github@kenzok8整理的 <ahref="https://github.com/kenzok8/openwrt-packages">openwrt-packages</a>，已经包括了以下插件和主题：</p><ul><li>luci-app-vssr ------------------vssr老竭力 即 helloworld</li><li>luci-app-dnsfilter ------------------基于DNS的广告过滤</li><li>luci-app-openclash ------------------openclash图形<br /></li><li>luci-app-advancedsetting ------------------系统高级设置</li><li>luci-app-serverchan ------------------Server酱 微信/Telegram推送的插件</li><li>luci-theme-ifit------------------透明主题（适配18.06修复主机名错误）</li><li>luci-theme-atmaterial ------------------atmaterial三合一主题（适配18.06）<br /></li><li>luci-app-aliddns ------------------阿里云ddns</li><li>luci-app-eqos ------------------依IP地址限速</li><li>luci-app-gost ------------------隐蔽的https代理</li><li>luci-app-adguardhome ------------------去广告</li><li>luci-app-smartdns ------------------smartdns防污染</li><li>luci-app-passwall ------------------Lienol大神</li><li>luci-theme-argon_new ------------------二合蓝 紫主题</li><li>luci-app-ssr-plus ------------------Lean大神</li><li>luci-theme-opentomcat------------------修复主机名错误（适配18.06）<br /></li><li>luci-theme-opentomato------------------修复主机名错误（适配18.06）</li></ul><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Openwrt03.png" /></p><p>如上图，编辑 lede/feeds.conf.default 文件，添加两行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">src-git kenzo https://github.com/kenzok8/openwrt-packages<br>src-git small https://github.com/kenzok8/small   // 这是 Passwall 插件所需的依赖，也可使用 Lienol passwall 替代<br></code></pre></td></tr></table></figure><p>保存关闭后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./scripts/feeds update -a<br>./scripts/feeds install -a<br>make menuconfig<br></code></pre></td></tr></table></figure><p>注意在第二步执行 install 命令时可能会出现一大堆有 ‘has a dependencyon xxx, which does not exist’ 依赖缺失的报错，再输一次命令确保无误再进行config 配置。（'use -f to .....'可以忽略，这是由于 kenzo8 提供的packages 和 core 里的包出现重复，-f 参数会覆盖原有的 packages）</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Openwrt04.png" /></p><p>输入 make menuconfig 后我们会看到这样一个图形界面：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Openwrt05.png" /></p><p>Target System 选择芯片 OEM，Subtarget 是具体型号，Target Profile机型。在终端底部有一个 Luci 选项卡，Luci所带来的高可定制性就是自己编译固件的乐趣所在。</p><p>LuCi &gt; Themes 可选择主题 argon 系列的都比较美观。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Openwrt06.png" /></p><p>LuCi &gt; Applications 里勾选所需要的插件，具体应用摘自恩山论坛：</p><p>—————————————————————————————–</p><p>LuCI —&gt; Applications —&gt; luci-app-accesscontrol#访问时间控制</p><p>LuCI —&gt; Applications —&gt; luci-app-adbyby-plus #广告屏蔽大师Plus+</p><p>LuCI —&gt; Applications —&gt; luci-app-arpbind #IP/MAC绑定</p><p>LuCI —&gt; Applications —&gt; luci-app-autoreboot #支持计划重启</p><p>LuCI —&gt; Applications —&gt; luci-app-ddns #动态域名DNS（集成阿里DDNS客户端）</p><p>LuCI —&gt; Applications —&gt; luci-app-filetransfer#文件传输（可web安装ipk包）</p><p>LuCI —&gt; Applications —&gt; luci-app-firewall #添加防火墙</p><p>LuCI —&gt; Applications —&gt; luci-app-flowoffload #TurboACC网络加速（集成FLOW,BBR,NAT,DNS…</p><p>LuCI —&gt; Applications —&gt; luci-app-frpc #内网穿透 Frp</p><p>LuCI —&gt; Applications —&gt; luci-app-guest-wifi #WiFi访客网络</p><p>LuCI —&gt; Applications —&gt; luci-app-ipsec-virtual<strong>d#virtual</strong>服务器 IPSec</p><p>LuCI —&gt; Applications —&gt; luci-app-mwan3 #MWAN3负载均衡</p><p>LuCI —&gt; Applications —&gt; luci-app-mwan3helper #MWAN3分流助手</p><p>LuCI —&gt; Applications —&gt; luci-app-nlbwmon #网络带宽监视器</p><p>LuCI —&gt; Applications —&gt; luci-app-ramfree #释放内存</p><p>LuCI —&gt; Applications —&gt; luci-app-samba #网络共享（Samba）</p><p>LuCI —&gt; Applications —&gt; luci-app-sqm#流量智能队列管理（QOS）</p><p>——————————————————————————————-</p><p>LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus#乳酸菌饮料低调上网Plus+</p><p>luci-app-乳酸菌饮料-plus —&gt; Include s-s New Versiong #新SS代理</p><p>luci-app-乳酸菌饮料-plus —&gt; Include s-s Simple-obfs Plugin#simple-obfs简单混淆工具 *</p><p>luci-app-乳酸菌饮料-plus —&gt; Include s-s v贰瑞 Plugin #SS v贰瑞插件*</p><p>luci-app-乳酸菌饮料-plus —&gt; Include v贰瑞 #v贰瑞代理</p><p>luci-app-乳酸菌饮料-plus —&gt; Include Trojan #Trojan代理</p><p>luci-app-乳酸菌饮料-plus —&gt; Include red—socks2 #red—socks2代理*</p><pre><code class="hljs">luci-app-乳酸菌饮料-plus —&gt; Include Kcptun  #Kcptun加速</code></pre><p>luci-app-乳酸菌饮料-plus —&gt; Include 违禁软件 Server#乳酸菌饮料服务器</p><p>——————————————————————————————-</p><p>LuCI —&gt; Applications —&gt; luci-app-syncdial#多拨虚拟网卡（原macvlan）</p><p>LuCI —&gt; Applications —&gt; luci-app-unblockmusic#解锁网易云灰色歌曲3合1新版本</p><p>LuCI —&gt; Applications —&gt; luci-app-upnp#通用即插即用UPnP（端口自动转发）</p><p>LuCI —&gt; Applications —&gt; luci-app-vlmcsd #KMS服务器设置</p><p>LuCI —&gt; Applications —&gt; luci-app-vsftpd #FTP服务器</p><p>LuCI —&gt; Applications —&gt; luci-app-wifischedule #WiFi 计划</p><p>LuCI —&gt; Applications —&gt; luci-app-wirele违禁软件egdb#WiFi无线</p><p>LuCI —&gt; Applications —&gt; luci-app-wol #WOL网络唤醒</p><p>LuCI —&gt; Applications —&gt; luci-app-wrtbwmon #实时流量监测</p><p>LuCI —&gt; Applications —&gt; luci-app-xlnetacc #迅雷快鸟</p><p>LuCI —&gt; Applications —&gt; luci-app-zerotier #ZeroTier内网穿透</p><p>Extra packages —&gt; ipv6helper #支持 ipv6</p><p>Utilities —&gt; open-vm-tools #打开适用于VMware的VM Tools</p><p>以下是全部： 注：应用后面标记 “ * ” 为最近新添加</p><p>—————————————————————————————–</p><p>LuCI —&gt; Applications —&gt; luci-app-accesscontrol#访问时间控制</p><p>LuCI —&gt; Applications —&gt; luci-app-acme#ACME自动化证书管理环境</p><p>LuCI —&gt; Applications —&gt; luci-app-adblock #ADB广告过滤</p><p>LuCI —&gt; Applications —&gt; luci-app-adbyby-plus #广告屏蔽大师Plus+</p><p>LuCI —&gt; Applications —&gt; luci-app-adbyby#广告过滤大师（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-adkill #广告过滤（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-advanced-reboot#Linksys高级重启</p><p>LuCI —&gt; Applications —&gt; luci-app-ahcp #支持AHCPd</p><p>LuCI —&gt; Applications —&gt; luci-app-aliddns#阿里DDNS客户端（已弃，集成至ddns）</p><p>LuCI —&gt; Applications —&gt; luci-app-amule #aMule下载工具</p><p>LuCI —&gt; Applications —&gt; luci-app-aria2 # Aria2下载工具</p><p>LuCI —&gt; Applications —&gt; luci-app-arpbind #IP/MAC绑定</p><p>LuCI —&gt; Applications —&gt; luci-app-asterisk#支持Asterisk电话服务器</p><p>LuCI —&gt; Applications —&gt; luci-app-attendedsysupgrade#固件更新升级相关</p><p>LuCI —&gt; Applications —&gt; luci-app-autoreboot #支持计划重启</p><p>LuCI —&gt; Applications —&gt; luci-app-baidupcs-web #百度网盘管理</p><p>LuCI —&gt; Applications —&gt; luci-app-bcp38#BCP38网络入口过滤（不确定）</p><p>LuCI —&gt; Applications —&gt; luci-app-bird1-ipv4#对Bird1-ipv4的支持</p><p>LuCI —&gt; Applications —&gt; luci-app-bird1-ipv6#对Bird1-ipv6的支持</p><p>LuCI —&gt; Applications —&gt; luci-app-bird4 #Bird4（未知）（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-bird6 #Bird6（未知）（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-bmx6 #BMX6路由协议</p><p>LuCI —&gt; Applications —&gt; luci-app-bmx7 #BMX7路由协议</p><p>LuCI —&gt; Applications —&gt; luci-app-caldav #联系人（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-cifsd #网络共享CIFS/SMB服务器*</p><p>LuCI —&gt; Applications —&gt; luci-app-cjdns #加密IPV6网络相关</p><p>LuCI —&gt; Applications —&gt; luci-app-clamav #ClamAV杀毒软件</p><p>LuCI —&gt; Applications —&gt; luci-app-commands #Shell命令模块</p><p>LuCI —&gt; Applications —&gt; luci-app-cshark #CloudShark捕获工具</p><p>LuCI —&gt; Applications —&gt; luci-app-ddns #动态域名DNS（集成阿里DDNS客户端）</p><p>LuCI —&gt; Applications —&gt; luci-app-diag-core #core诊断工具</p><p>LuCI —&gt; Applications —&gt; luci-app-dnscrypt-proxy#DNSCrypt解决DNS污染</p><p>LuCI —&gt; Applications —&gt; luci-app-dnsforwarder#DNSForwarder防DNS污染</p><p>LuCI —&gt; Applications —&gt; luci-app-dnspod#DNSPod动态域名解析（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-dockerman #Docker容器 *</p><p>LuCI —&gt; Applications —&gt; luci-app-dump1090#民航无线频率（不确定）</p><p>LuCI —&gt; Applications —&gt; luci-app-dynapoint#DynaPoint（未知）</p><p>LuCI —&gt; Applications —&gt; luci-app-e2guardian #Web内容过滤器</p><p>LuCI —&gt; Applications —&gt; luci-app-familycloud #家庭云盘</p><p>LuCI —&gt; Applications —&gt; luci-app-filetransfer#文件传输（可web安装ipk包）</p><p>LuCI —&gt; Applications —&gt; luci-app-firewall #添加防火墙</p><p>LuCI —&gt; Applications —&gt; luci-app-flowoffload #TurboACC网络加速（集成FLOW,BBR,NAT,DNS…</p><p>LuCI —&gt; Applications —&gt; luci-app-freifunk-diagnostics#freifunk组件 诊断（未知）</p><p>LuCI —&gt; Applications —&gt; luci-app-freifunk-policyrouting#freifunk组件 策略路由（未知）</p><p>LuCI —&gt; Applications —&gt; luci-app-freifunk-widgets #freifunk组件索引（未知）</p><p>LuCI —&gt; Applications —&gt; luci-app-frpc #内网穿透 Frp</p><p>LuCI —&gt; Applications —&gt; luci-app-fwknopd #Firewall KnockOperator服务器</p><p>LuCI —&gt; Applications —&gt; luci-app-guest-wifi #WiFi访客网络</p><p>LuCI —&gt; Applications —&gt; luci-app-gfwlist#GFW域名列表（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-haproxy-tcp#HAProxy负载均衡-TCP</p><p>LuCI —&gt; Applications —&gt; luci-app-hd-idle #硬盘休眠</p><p>LuCI —&gt; Applications —&gt; luci-app-hnet #HomenetStatus家庭网络控制协议</p><p>LuCI —&gt; Applications —&gt; luci-app-ipsec-virtual<strong>d#virtual</strong>服务器 IPSec</p><p>LuCI —&gt; Applications —&gt; luci-app-kodexplorer#KOD可道云私人网盘</p><p>LuCI —&gt; Applications —&gt; luci-app-kooldns #virtual**服务器ddns替代方案（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-koolproxy#KP去广告（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-lxc #LXC容器管理</p><p>LuCI —&gt; Applications —&gt; luci-app-meshwizard #网络设置向导</p><p>LuCI —&gt; Applications —&gt; luci-app-minidlna #完全兼容DLNA /UPnP-AV客户端的服务器软件</p><p>LuCI —&gt; Applications —&gt; luci-app-mjpg-streamer#兼容Linux-UVC的摄像头程序</p><p>LuCI —&gt; Applications —&gt; luci-app-mtwifi #MTWiFi驱动的支持</p><p>LuCI —&gt; Applications —&gt; luci-app-mmc-over-gpio#添加SD卡操作界面（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-multiwan#多拨虚拟网卡（已弃，移至syncdial）</p><p>LuCI —&gt; Applications —&gt; luci-app-mwan #MWAN负载均衡（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-mwan3 #MWAN3负载均衡</p><p>LuCI —&gt; Applications —&gt; luci-app-mwan3helper #MWAN3分流助手</p><p>LuCI —&gt; Applications —&gt; luci-app-n2n_v2 #N2N内网穿透 N2N v2virtual**服务</p><p>LuCI —&gt; Applications —&gt; luci-app-netdata#Netdata实时监控（图表）</p><p>LuCI —&gt; Applications —&gt; luci-app-nft-qos #QOS流控Nftables版</p><p>LuCI —&gt; Applications —&gt; luci-app-ngrokc #Ngrok内网穿透（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-nlbwmon #网络带宽监视器</p><p>LuCI —&gt; Applications —&gt; luci-app-noddos #NodDOS Clients阻止DDoS攻击</p><p>LuCI —&gt; Applications —&gt; luci-app-nps #内网穿透nps *</p><p>LuCI —&gt; Applications —&gt; luci-app-ntpc #NTP时间同步服务器</p><p>LuCI —&gt; Applications —&gt; luci-app-ocserv #OpenConnectvirtual**服务</p><p>LuCI —&gt; Applications —&gt; luci-app-olsr #OLSR配置和状态模块</p><p>LuCI —&gt; Applications —&gt; luci-app-olsr-services #OLSR服务器</p><p>LuCI —&gt; Applications —&gt; luci-app-olsr-viz #OLSR可视化</p><p>LuCI —&gt; Applications —&gt; luci-app-openvirtual**#Openvirtual**客户端</p><p>LuCI —&gt; Applications —&gt; luci-app-openvirtual<strong>-server#易于使用的Openvirtual</strong>服务器 Web-UI</p><p>LuCI —&gt; Applications —&gt; luci-app-oscam #OSCAM服务器（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-p910nd #打印服务器模块</p><p>LuCI —&gt; Applications —&gt; luci-app-pagekitec#Pagekite内网穿透客户端</p><p>LuCI —&gt; Applications —&gt; luci-app-polipo#Polipo代理(是一个小型且快速的网页缓存代理)</p><p>LuCI —&gt; Applications —&gt; luci-app-pppoe-relay #PPPoE NAT穿透点对点协议（PPP）</p><p>LuCI —&gt; Applications —&gt; luci-app-p p t p-server#virtual**服务器 p p t p（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-privoxy#Privoxy网络代理(带过滤无缓存)</p><p>LuCI —&gt; Applications —&gt; luci-app-qbittorrent#BT下载工具（qBittorrent）</p><p>LuCI —&gt; Applications —&gt; luci-app-qos #流量服务质量(QoS)流控</p><p>LuCI —&gt; Applications —&gt; luci-app-radicale#CalDAV/CardDAV同步工具</p><p>LuCI —&gt; Applications —&gt; luci-app-ramfree #释放内存</p><p>LuCI —&gt; Applications —&gt; luci-app-rp-pppoe-server #RoaringPenguin PPPoE Server 服务器</p><p>LuCI —&gt; Applications —&gt; luci-app-samba #网络共享（Samba）</p><p>LuCI —&gt; Applications —&gt; luci-app-samba4 #网络共享（Samba4）</p><p>LuCI —&gt; Applications —&gt; luci-app-sfe #TurboACC网络加速（flowoffload二选一）</p><p>LuCI —&gt; Applications —&gt; luci-app-s-s #SS低调上网（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-s-s-libes #SS-libev服务端</p><p>LuCI —&gt; Applications —&gt; luci-app-shairplay #支持AirPlay功能</p><p>LuCI —&gt; Applications —&gt; luci-app-siitwizard #SIIT配置向导SIIT-Wizzard</p><p>LuCI —&gt; Applications —&gt; luci-app-simple-adblock#简单的广告拦截</p><p>LuCI —&gt; Applications —&gt; luci-app-smartdns#SmartDNS本地服务器（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-softethervirtual** #SoftEthervirtual**服务器 NAT穿透 *</p><p>LuCI —&gt; Applications —&gt; luci-app-splash#Client-Splash是无线MESH网络的一个热点认证系统</p><p>LuCI —&gt; Applications —&gt; luci-app-sqm#流量智能队列管理（QOS）</p><p>LuCI —&gt; Applications —&gt; luci-app-squid #Squid代理服务器</p><p>——————————————————————————————————-</p><p>LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus#乳酸菌饮料低调上网Plus+</p><p>luci-app-乳酸菌饮料-plus —&gt; Include s-s New Version #新SS代理</p><p>luci-app-乳酸菌饮料-plus —&gt; Include s-s Simple-obfs Plugin#simple-obfs简单混淆工具 *</p><p>luci-app-乳酸菌饮料-plus —&gt; Include s-s v贰瑞 Plugin #SS v贰瑞插件*</p><p>luci-app-乳酸菌饮料-plus —&gt; Include v贰瑞 #v贰瑞代理</p><p>luci-app-乳酸菌饮料-plus —&gt; Include Trojan #Trojan代理</p><p>luci-app-乳酸菌饮料-plus —&gt; Include red—socks2 #red—socks2代理*</p><p>luci-app-乳酸菌饮料-plus —&gt; Include Kcptun #Kcptun加速</p><p>luci-app-乳酸菌饮料-plus —&gt; Include 违禁软件 Server#乳酸菌饮料服务器</p><p>luci-app-乳酸菌饮料-plus —&gt; Include DNS2SOCKS#DNS服务器（已弃）</p><p>luci-app-乳酸菌饮料-plus —&gt; Include 违禁软件 Socks andTunnel（已弃）</p><p>luci-app-乳酸菌饮料-plus —&gt; Include Socks Server#socks代理服务器（已弃）</p><p>——————————————————————————————————-</p><p>LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-pro#乳酸菌饮料-Pro（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料server-python#违禁软件 Python服务器</p><p>LuCI —&gt; Applications —&gt; luci-app-statistics #流量监控工具</p><p>LuCI —&gt; Applications —&gt; luci-app-syncdial#多拨虚拟网卡（原macvlan）</p><p>LuCI —&gt; Applications —&gt; luci-app-tinyproxy #Tinyproxy是HTTP(S)代理服务器</p><p>LuCI —&gt; Applications —&gt; luci-app-transmission #BT下载工具</p><p>LuCI —&gt; Applications —&gt; luci-app-travelmate #旅行路由器</p><p>LuCI —&gt; Applications —&gt; luci-app-ttyd #网页终端命令行</p><p>LuCI —&gt; Applications —&gt; luci-app-udpxy #udpxy做组播服务器</p><p>LuCI —&gt; Applications —&gt; luci-app-uhttpd #uHTTPd Web服务器</p><p>——————————————————————————————————-</p><p>LuCI —&gt; Applications —&gt; luci-app-unblockmusic#解锁网易云灰色歌曲3合1新版本</p><p>UnblockNeteaseMusic Golang Version #Golang版本 *</p><p>UnblockNeteaseMusic NodeJS Version #NodeJS版本 *</p><p>——————————————————————————————————-</p><p>LuCI —&gt; Applications —&gt; luci-app-unblockneteasemusic-go#解除网易云音乐（合并）</p><p>LuCI —&gt; Applications —&gt; luci-app-unblockneteasemusic-mini#解除网易云音乐（合并）</p><p>LuCI —&gt; Applications —&gt; luci-app-unbound #Unbound DNS解析器</p><p>LuCI —&gt; Applications —&gt; luci-app-upnp#通用即插即用UPnP（端口自动转发）</p><p>LuCI —&gt; Applications —&gt; luci-app-usb-printer #USB打印服务器</p><p>LuCI —&gt; Applications —&gt; luci-app-v贰瑞-server #v贰瑞 服务器</p><p>LuCI —&gt; Applications —&gt; luci-app-v贰瑞-pro#v贰瑞透明代理（已弃，集成乳酸菌饮料）</p><p>LuCI —&gt; Applications —&gt; luci-app-verysync #微力同步 *</p><p>LuCI —&gt; Applications —&gt; luci-app-vlmcsd #KMS服务器设置</p><p>LuCI —&gt; Applications —&gt; luci-app-vnstat#vnStat网络监控（图表）</p><p>LuCI —&gt; Applications —&gt; luci-app-virtual<strong>bypass#virtual</strong> BypassWebUI 绕过virtual**设置</p><p>LuCI —&gt; Applications —&gt; luci-app-vsftpd #FTP服务器</p><p>LuCI —&gt; Applications —&gt; luci-app-watchcat#断网检测功能与定时重启</p><p>LuCI —&gt; Applications —&gt; luci-app-webadmin #Web管理页面设置</p><p>LuCI —&gt; Applications —&gt; luci-app-webshell#网页命令行终端（已弃）</p><p>LuCI —&gt; Applications —&gt; luci-app-wifischedule #WiFi 计划</p><p>LuCI —&gt; Applications —&gt; luci-app-wireguard #virtual**服务器WireGuard状态</p><p>LuCI —&gt; Applications —&gt; luci-app-wirele违禁软件egdb#WiFi无线</p><p>LuCI —&gt; Applications —&gt; luci-app-wol #WOL网络唤醒</p><p>LuCI —&gt; Applications —&gt; luci-app-wrtbwmon #实时流量监测</p><p>LuCI —&gt; Applications —&gt; luci-app-xlnetacc #迅雷快鸟</p><p>LuCI —&gt; Applications —&gt; luci-app-zerotier #ZeroTier内网穿透</p><p>—————————————————————————————————</p><p>需要注意的是配置科学上网工具时，XRay 是向下兼容 V2ray的。并且经过我的测试，勾选了 V2Ray 可能会导致 XRay 编译时出现错误。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Openwrt07.png" /></p><p>双击两下 Esc 退回上一级，并选择 Yes保存文件。下载编译所需的第三方库（每次更改配置文件时都需执行一次）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j8 download V=s<br></code></pre></td></tr></table></figure><p>这里千万不要只执行一遍就直接编译了，必会报错！！由于玄学问题第一次下载哪怕用的是海外VPS 都会出现 404 Downloadfailed，所以至少重复两至三遍。方便排错可以直接搜索 'failed'关键字进行过滤，sha256 签名验证失败的文件可以忽略，只要在 lede/dl目录能找到对应报错的文件就可以了。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Openwrt08.png" /></p><p>最后开始编译，本机大约等待了 6h：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j1 V=s<br></code></pre></td></tr></table></figure><p>我在编译到最后一步打包时，出现了 'error:ext4_allocate_best_fit_partial: failed to allocate xxxx blocks, out ofspace?' error，原因很简单：默认的磁盘大小不够。只需重新 makemenuconfig，找到 Target Images &gt; Root filesystem partition size(inMB)，根据所编译的插件数量酌情扩容。</p><p>Billy Shao,</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WhateverGreen核显驱动详解</title>
    <link href="/2021/05/15/WhateverGreen/"/>
    <url>/2021/05/15/WhateverGreen/</url>
    
    <content type="html"><![CDATA[<p>参考文档： - <ahref="http://bbs.pcbeta.com/forum.php?mod=viewthread&amp;tid=1849093">远景·英特尔全系核显显卡驱动教程</a>- <ahref="https://github.com/acidanthera/WhateverGreen/blob/master/Manual/FAQ.IntelHD.en.md">WhateverGreen文档·Intel®HD Graphics FAQs</a> - <ahref="https://dortania.github.io/OpenCore-Post-Install/gpu-patching/intel-patching/#getting-started">Dortania'sIntel iGPU Patching</a></p><p>早期黑苹果通常直接使用 Clover补丁注入显卡，然而这种方法从10.14版本以来便不再受到支持，稳定且长期支持的方案还是要选择WhateverGreen。作为高集成度的显卡驱动，目前集成了WhateverGreen，IntelGraphicsFixup，NvidiaGraphicsFixup，Shiki 和CoreDisplayFixup，支持 AMD/ATI/Intel/Nvidia （N卡需要使用WebDriver，且最高支持到10.13.6；开普勒架构大部分免驱）。本篇文章主要讨论核显驱动，内容可能会有一点冗长，确保你有足够的耐心进行阅读。︿(￣︶￣)︿</p><p>macOS 对 HD 2000（Sandy Bridge 架构简称SNB）系列及以上的核显提供相对完整的支持。如果独显能够正常驱动，必须配合核显驱动以及合适的缓冲帧（Framebuffer简称FB），才能实现硬件加速，这也成为了一台”完美“的黑苹果电脑的重要指标之一。</p><h2 id="开始前要做的...">开始前要做的...</h2><p>正确启用核显步骤：</p><p>1.修正设备的 ACPI 名称（核显是 IGPU，英特尔管理引擎是IMEI）。事实上，这一步 WhateverGreen 会自动完成，必要的时候还需要在 ACPI-&gt; Patch 中手动打替换补丁如 Rename GPU0 to IGPU，Rename PEGP toIGPU。</p><p>2.仿冒设备为合适的型号。</p><p>3.写入正确的 FB，即 AAPL,ig-platform-id（适用于 Ivy Bridge 或更新）或AAPL,snb-platform-id （仅适用于 Sandy Bridge），是最为关键的步骤。</p><p>4.与核显相关设备会由 WhateverGreen 和 AppleALC自动添加额外的属性。</p><p>BIOS 设置建议（图片来自<ahref="https://github.com/acidanthera/WhateverGreen/blob/master/Manual/FAQ.IntelHD.en.md">WhateverGreen文档·Intel®HD Graphics FAQs</a>）：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/WhateverGreenbios.png" /></p><p>将 DVMT 内存量设置为MAX；如果BIOS中没有该选项（大多数笔记本不支持），之后会讲如何使用framebuffer-stolenmem 给 BIOS 中 DVMT 添加内存大小。</p><p>开始之前需要做一下引导的清理工作，移除下列驱动：</p><ul><li>IntelGraphicsFixup</li><li>NvidiaGraphicsFixup</li><li>CoreDisplayFixup</li><li>Shiki</li><li>IntelGraphicsDVMTFixup</li><li>AzulPatcher4600</li><li>AppleBacklightFixup</li><li>FakePCIID_Intel_HD_Graphics</li><li>FakePCIID_Intel_HDMI_Audio</li><li>FakePCIID.kext（不使用其他依赖于 FakePCIID 的插件时）</li></ul><p>以下针对 Clover 用户：</p><p>关闭所有显卡注入参数 Graphics-Inject-ATI/Intel/NVidia Devices-Inject全部设置为 false。并点掉以下 Clover 的 DSDT 补丁：</p><ul><li>AddHDMI</li><li>FixDisplay</li><li>FixIntelGfx</li><li>AddIMEI</li><li>FixHDA</li><li>AddPNLF</li></ul><p>同时关闭 UseIntelHDMI，SetIntelBacklight 和SetIntelMaxBacklight。删除 -disablegfxfirmware 和 -igfxnohdmi启动参数。删除或注释 IntelGFX，IMEI 的 FakeID 和ig-platform-id。清除以下位置所有和 IGPU，HDMI 相关的条目：</p><ul><li>config.plist ▸ Devices ▸ Arbitrary</li><li>config.plist ▸ Devices ▸ Properties</li><li>config.plist ▸ Devices ▸ AddProperties</li></ul><p>最后一步，清除 DSDT Patches：GFX0 to IGPU, PEGP to GFX0, HECI toIMEI, MEI to IMEI, HDAS to HDEF, B0D3 to HDAU。</p><h2 id="案例i5-10210u">案例：i5-10210u</h2><h3 id="获取设备路径">1.获取设备路径</h3><p>以 i5-10210u 的核显 Intel UHD Graphcis （应该是 UHD620的一张马甲卡）为例子，首先需要找到核显的 Pci 设备路径。通常是PciRoot(0x0)/Pci(0x2,0x0)，但还是需要使用 gfx-util 进行确认。软件可在acidanthera 团队维护的仓库里下载 release 版本，项目地址：<ahref="https://github.com/acidanthera/gfxutil">https://github.com/acidanthera/gfxutil</a>。终端输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; ./gfxutil | grep IGPU<br>00:02.0 8086:3e9b /PCI0@0/IGPU@2 = PciRoot(0x0)/Pci(0x2,0x0)<br></code></pre></td></tr></table></figure><h3 id="注入-framebuffer-缓冲帧">2.注入 Framebuffer 缓冲帧</h3><p>config -&gt; DeviceProperties -&gt; Add 中添加一个 Dictionary命名为你的核显路径。首先添加 Frambuffer，这是核显驱动中最核心的步骤。Dic下添加 Data 类型的 AAPL,ig-platform-id 或 AAPL,snb-platform-id 子项指定FB 值，请首先使用对应型号和架构的 recommanded值，如果无法驱动可以依次尝试其他的。</p><p>在案例下方的内容中，我放出了从最初到10代 CFL/CML核显的所有信息，大部分内容摘自<ahref="https://github.com/acidanthera/WhateverGreen/blob/master/Manual/FAQ.IntelHD.en.md">WhateverGreen文档·Intel®HD Graphics FAQs</a>，由于是10代 Comet Lake 我这里选择：</p><p><strong>推荐的 Framebuffers</strong>:</p><ul><li>Desktop:<ul><li>0x3EA50000 (default)</li><li>0x3E9B0007 (recommended)</li></ul></li><li>Laptop:<ul><li>0x3EA50009 (default). &lt;=====</li></ul></li><li>Empty framebuffer (CFL):<ul><li>0x3E910003 (default)</li></ul></li><li>Empty framebuffer (CML):<ul><li>0x9BC80003 (default)</li></ul></li></ul><p>由于 OC 特性，十六进制数 0x3EA50009 需要去掉 0x 两两一组倒序填入ig-platform-id 参数，这里是 0900A53E。所以填进去的信息应是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">AAPL,ig-platform-idData0900A53E<br></code></pre></td></tr></table></figure><p>如果不明白倒序输入的具体含义，可以参阅 <ahref="http://bbs.pcbeta.com/forum.php?mod=viewthread&amp;tid=1849093">远景·英特尔全系核显显卡驱动教程</a>，这个教程有详细的图文介绍。</p><h3 id="device-id-仿冒核显">3.device-id 仿冒核显</h3><p>device-id参数的作用是仿冒核显型号，但仿冒并不是必须的。如果你的核显使用了缓冲帧指定平台后依然不能正常工作，可以尝试仿冒。</p><p>每一代核显的 FB 列表下都有 ‘原生支持的Dev ID’，这些16进制的核显ID就是device-id 需要填入的数值。</p><p>举个例子，我要选择 CFL 的 0x3E9B 作为仿冒 ID，倒序输入后用 0 补齐至 8位，像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">device-idData9B3E0000<br></code></pre></td></tr></table></figure><h3 id="weg-自定义补丁列表">4.WEG 自定义补丁列表</h3><p>Lilu 核心拓展 + WhateverGreen 并称为WEG。一般情况下不需要手动去定制额外的 Framebuffer补丁。但如果出现花屏，BIOS 不能设置 DVMT等情况自定义补丁就派上用场，常用的如下：</p><ul><li><p>framebuffer-patch-enable (启用语义补丁的总开关)</p></li><li><p>framebuffer-framebufferid (要修改的FB，一般保持默认即可)</p></li><li><p>framebuffer-mobile</p></li><li><p>framebuffer-pipecount</p></li><li><p>framebuffer-portcount</p></li><li><p>framebuffer-memorycount</p></li><li><p>framebuffer-stolenmem(给BIOS中DVMT增加内存大小）：</p></li><li><p>framebuffer-fbmem</p></li><li><p>framebuffer-unifiedmem(核显显存大小，调大一点可能能解决花屏）</p></li><li><p>framebuffer-cursormem (Haswell 专用补丁)</p></li><li><p>framebuffer-flags</p></li><li><p>framebuffer-camellia (集成显示控制器，仅与白苹果相关)</p></li><li><p>framebuffer-conX-enable (启用端口为 X 的修改)</p></li><li><p>framebuffer-conX-index</p></li><li><p>framebuffer-conX-busid</p></li><li><p>framebuffer-conX-pipe</p></li><li><p>framebuffer-conX-type</p></li><li><p>framebuffer-conX-flags</p></li><li><p>framebuffer-conX-alldata (完全替换端口信息)</p></li><li><p>framebuffer-conX-YYYYYYYY-alldata (在当前 FB 与 YYYYYY匹配时完全替换端口信息)</p></li></ul><p>接下来是详细的补丁过程，主要修补3个方面：</p><p>（1）显存（2）核显接口（Connectors）配置</p><p>一.修复显存问题</p><p>打开 <ahref="https://github.com/acidanthera/WhateverGreen/blob/master/Manual/FAQ.IntelHD.en.md">WhateverGreen文档·Intel®HD Graphics FAQs</a>，展开 Spoiler: CFL/CML connectors，我是用Framebuffer 是 0x3EA50009，搜索 0900A53E会发现以下信息，即默认配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">ID: 3EA50009, STOLEN: 57 MB, FBMEM: 0 bytes, VRAM: 1536 MB, Flags: 0x00830B0A<br>TOTAL STOLEN: 58 MB, TOTAL CURSOR: 1 MB (1572864 bytes), MAX STOLEN: 172 MB, MAX OVERALL: 173 MB (181940224 bytes)<br>Model name: Intel HD Graphics CFL CRB<br>Camellia: CamelliaV3 (3), Freq: 0 Hz, FreqMax: 0 Hz<br>Mobile: 1, PipeCount: 3, PortCount: 3, FBMemoryCount: 3<br>[0] busId: 0x00, pipe: 8, <span class="hljs-built_in">type</span>: 0x00000002, flags: 0x00000098 - ConnectorLVDS<br>[1] busId: 0x05, pipe: 9, <span class="hljs-built_in">type</span>: 0x00000400, flags: 0x000001C7 - ConnectorDP<br>[2] busId: 0x04, pipe: 10, <span class="hljs-built_in">type</span>: 0x00000400, flags: 0x000001C7 - ConnectorDP<br>00000800 02000000 98000000<br>01050900 00040000 C7010000<br>02040A00 00040000 C7010000<br></code></pre></td></tr></table></figure><p>名词解释：</p><table><thead><tr class="header"><th style="text-align: left;">标识符</th><th style="text-align: left;">值</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">STOLEN</td><td style="text-align: left;">57 MB</td><td style="text-align: left;">在 BIOS DVMT设置的基础上给核显增加的额外显存</td></tr><tr class="even"><td style="text-align: left;">FBMEM</td><td style="text-align: left;">0 bytes</td><td style="text-align: left;">缓冲帧保留内存</td></tr><tr class="odd"><td style="text-align: left;">TOTAL CURSOR</td><td style="text-align: left;">1 MB</td><td style="text-align: left;">光标内存</td></tr><tr class="even"><td style="text-align: left;">TOTAL STOLEN</td><td style="text-align: left;">58 MB</td><td style="text-align: left;">以上三项之和</td></tr><tr class="odd"><td style="text-align: left;">VRAM</td><td style="text-align: left;">1536 MB</td><td style="text-align: left;">核显动态内存值，会在关于本机中显示</td></tr></tbody></table><p>首先启用 framebuffer 补丁总开关：</p><p>framebuffer-patch-enable：</p><ul><li><p>DATA 数据：01000000-&gt; 1（启用） 00000000 -&gt;0（不启用）</p></li><li><p>NUMBER 数据：0（不启用） 1（启用）</p></li></ul><p>另外可能需要以下补丁：</p><p>1.framebuffer-stolenmem，对应修改表格中的 STOLEN值，对于高分辨率屏幕很重要，但也不应设置太高：</p><ul><li>一般 1080P ，设置为 19 M 可以：00003001</li><li>2K 屏幕设置为64M：00000004</li><li>4K 尝试128M：00000008（本人没有尝试过 <del>4K屏幕太贵</del>）</li></ul><p>以19M 的Stolen Memory为例，FBMEM 和 STOLEN具体的换算方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">i. 兆字节转换为字节<br>19 x 1024 ^ 2 = 19922944<br><br>ii.十进制转换为十六进制（可使用 Hackintool 计算器）<br>19922944 -&gt; 1300000<br><br>iii.从开头补0并补齐8个字符，再两两一组倒序排列<br>1300000 -&gt; 01300000 -&gt; 01 30 00 00 -&gt; 00 00 30 01 -&gt; 00003001<br></code></pre></td></tr></table></figure><p>2.framebuffer-fbmem，对应修改表格中的 FBMEM 值： - 一般屏幕设置成 9M大小就好：00009000 - 高分屏的话最好直接设置成 48M：00000003</p><p>3.framebuffer-unifiedmem，对应修改表格中的 VRAM值，除非重度强迫症，一般情况保持原生不建议修改。比如我原默认现存1536M，可以通过此补丁修改为2048M： - 2048M：00000080 - 3072M：000000C0</p><p>4.framebuffer-cursormem（Hasswell 平台专属，可能解决花屏问题）： -一般屏幕设置成 9M 大小就好：00009000 - 高分屏的话最好直接设置成48M：00000003</p><p>二.修复核显接口</p><p>按理说，第一部分的配置基本上可以正常工作了。但如果出现外界显示屏黑屏的情况，就需要定制核显接口了。</p><p>还是回到 3EA50009 的 Spoiler 信息，其中我们可以看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0] busId: 0x00, pipe: 8, <span class="hljs-built_in">type</span>: 0x00000002, flags: 0x00000098 - ConnectorLVDS<br>[1] busId: 0x05, pipe: 9, <span class="hljs-built_in">type</span>: 0x00000400, flags: 0x000001C7 - ConnectorDP<br>[2] busId: 0x04, pipe: 10, <span class="hljs-built_in">type</span>: 0x00000400, flags: 0x000001C7 - ConnectorDP<br>00000800 02000000 98000000<br>01050900 00040000 C7010000<br>02040A00 00040000 C7010000<br></code></pre></td></tr></table></figure><p>显然易见，该缓冲帧有3个输出接口，一个 LVDS（通常是笔记本内建输出）两个 DP 输出。后三行的数值分别对应每一个connector，如 con0 接口的完整信息是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0] busId: 0x00, pipe: 8, <span class="hljs-built_in">type</span>: 0x00000002, flags: 0x00000098 - ConnectorLVDS<br>00000800 02000000 98000000<br></code></pre></td></tr></table></figure><p>不妨让两位为1 Bit 那么：</p><ul><li><p>Bit1 00。代表的是接口编号，以此类推有01 02</p></li><li><p>Bit2 00。代表的是 BusID，加上0x就对应了 ‘busId: 0x00’</p></li><li><p>Bit3-4 0800。指该 connector 对应的 pipe 编号</p></li><li><p>Bit5-8 02000000。此值表示接口的类型。从中可以得知 LVDS 接口对应着02000000。同理。我们可以看到如下对应关系：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;02 00 00 00&gt;        LVDS and eDP      // 笔记本内建显示输出<br>&lt;10 00 00 00&gt;        VGA              <br>&lt;00 04 00 00&gt;        DisplayPort       // DP 或 VGA<br>&lt;01 00 00 00&gt;        DUMMY             // 无物理接口时<br>&lt;00 08 00 00&gt;        HDMI<br>&lt;80 00 00 00&gt;        S-Video // S端子输出，老古董了<br>&lt;04 00 00 00&gt;        DVI (Dual Link)// DVI老古董了<br>&lt;00 02 00 00&gt;        DVI (Single Link)<br><br>注意：VGA接口在10.8以及更新系统上使用 00040000 代替 10000000，10000000 在老版本系统上使用<br></code></pre></td></tr></table></figure><p>这些都是理论知识储备，来验证一下是不是这样的？打开IORegistryExplorer，搜索 IGPU定位到核显位置，再点一下搜索框的叉叉以显示他下面的所有子项。我们可以看到AppleIntelFramebuffer@0 AppleIntelFramebuffer@1AppleIntelFramebuffer@2，分别对应 con0，con1 和 con2。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/WhateverGreen02.png" /></p><p>con0 已经被 LVDS 接口占用，这是如果要使用 HDMI 输出，则需要修改 con1接口。</p><p>1.framebuffer-conN-enable（conN 接口是否启用补丁）：</p><ul><li>DATA 数据：01000000 -&gt; 1（启用） 00000000 -&gt; 0（不启用）</li><li>NUMBER 数据：0（不启用） 1（启用）</li></ul><p>2.framebuffer-conN-type，指定 conN 输出类型</p><p>3.framebuffer-conN-index（设置 conN的索引值，会指定接口的优先级）:这个按个人需要设置，如果需要屏蔽这个输出口，可以设置成FFFFFFFF，也就是最大的数字，让它足够靠后，这样就达到了屏蔽效果！</p><p>4.framebuffer-conX-busid，指定 conN 的总线ID，BusID可经过反复尝试获得最佳值并且个 BusID 最多只能有一个接口与之对应。</p><p>5.framebuffer-conX-alldata，替换接口的所有信息字节。</p><p>最后贴一张 i5 10210u 较完美的配置，H256 HEVC 编码都支持 4K硬件加速。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/WhateverGreen03.png" /></p><p><del>结束了？还没呢，就是玩</del></p><p>1.HDMI 高分屏支持 60fps，需要添加 enable-hdmi20 属性，与 -cdfon启动参数效果一致。</p><p>2.禁用独显可添加 disable-external-gpu，引导参数 -wegnoegpu可达到同样的效果。但事实上如果是采用 AOAC模式睡眠的新款笔记本独立显卡此时还在偷电，只是微乎其微，想要彻底屏蔽独显需要SSDT-NDGP_OFF-AOAC.aml 补丁，具体参考 OC-little 这里不再展开。</p><p>3.WEG还提供了二进制补丁，实际上根本用不到，其实我自己也没有研究过，补充一下：</p><p>framebuffer-patchN-enable (enabling patch number N)</p><p>framebuffer-patchN-framebufferid (the framebuffer that we'repatching, the current by default)</p><p>framebuffer-patchN-find</p><p>framebuffer-patchN-replace</p><p>framebuffer-patchN-count (the amount of pattern iterations to searchfor, the default is 1)</p><h2 id="intel-hd-graphicsironlake-一代远古版本">Intel HDGraphics（Ironlake 一代远古版本）</h2><p>按理说一代并不在驱动支持的范围之内，但还是有解决办法的，详见 Gurus大神的帖子https://www.insanelymac.com/forum/topic/286092-guide-1st-generation-intel-hd-graphics-qeci</p><p>注意：一代核显支持 Mac OS X 10.6.x 到 macOS10.13.6，更高版本系统不支持。且只能使用 LVDS 显示屏。</p><p>原生支持的Dev ID： 0x0042 0x0046</p><h2 id="intel-hd-graphics-20003000-sandy-bridge架构">Intel HD Graphics2000/3000 (Sandy Bridge架构)</h2><p>支持系统版本：Mac OS X 10.7.x to macOS 10.13.6</p><p>SNB FB 列表：</p><table><thead><tr class="header"><th style="text-align: left;">Framebuffer值</th><th style="text-align: left;">Type类型</th><th style="text-align: left;">Connectors输出接口数</th><th style="text-align: left;">TOTAL STOLEN Memory</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0x00010000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">4</td><td style="text-align: left;">32 MB</td></tr><tr class="even"><td style="text-align: left;">0x00020000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">1</td><td style="text-align: left;">32 MB</td></tr><tr class="odd"><td style="text-align: left;">0x00030010</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">32 MB</td></tr><tr class="even"><td style="text-align: left;">0x00030020</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">32 MB</td></tr><tr class="odd"><td style="text-align: left;">0x00030030</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">32 MB</td></tr><tr class="even"><td style="text-align: left;">0x00040000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">32 MB</td></tr><tr class="odd"><td style="text-align: left;">0x00050000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">32 MB</td></tr></tbody></table><p>原生支持的Dev ID： 0x0106 0x1106 0x1601 0x0116 0x0126 0x0102</p><p><strong>推荐的 Framebuffers</strong>：</p><ul><li>Desktop：0x00030010</li><li>Laptop： 0x00010000</li><li>空缓冲帧： 0x00050000</li></ul><p>注意：</p><p>1.只有 HD3000 能够直接驱动，HD2000需要选择空缓冲帧以使 IQSV正常工作，具体详见https://www.applelife.ru/threads/zavod-intel-quick-sync-video.817923/</p><p><del>（只有俄文版本，反正我自己没看过，根本看不懂）</del></p><p>2.通常 SNB 平台不用写 FB，WhateverGreen 会根据 board-id 值自动补充FB。如果不是 SNB 架构（如 Ivy + HD3000 的 MacBookPro9,1）需要指定FB，AAPL,snb-platform-id 可以写 10000300。</p><p>3.桌面级需要仿冒 device-id 为 26010000。</p><p>4.如果是7系列主板（如 X79，Z75，Z77 芯片组）需要仿冒 device-id 为3A1C0000，并且打上 <ahref="https://github.com/acidanthera/OpenCorePkg/blob/master/Docs/AcpiSamples/Source/SSDT-IMEI.dsl">SSDT-IMEI</a>补丁</p><h2 id="intel-hd-graphics-25004000-ivy-bridge架构">Intel HD Graphics2500/4000 (Ivy Bridge架构)</h2><p>支持 OS X 10.8.x 及更新版本。</p><p>Ivy FB 列表：</p><table><thead><tr class="header"><th style="text-align: left;">Framebuffer值</th><th style="text-align: left;">Type类型</th><th style="text-align: left;">Connectors输出接口数</th><th style="text-align: left;">TOTAL STOLEN Memory</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0x01660000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">4</td><td style="text-align: left;">24 MB</td></tr><tr class="even"><td style="text-align: left;">0x01620006</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">0 bytes</td></tr><tr class="odd"><td style="text-align: left;">0x01620007</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">0 bytes</td></tr><tr class="even"><td style="text-align: left;">0x01620005</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">16 MB</td></tr><tr class="odd"><td style="text-align: left;">0x01660001</td><td style="text-align: left;">mobile</td><td style="text-align: left;">4</td><td style="text-align: left;">24 MB</td></tr><tr class="even"><td style="text-align: left;">0x01660002</td><td style="text-align: left;">mobile</td><td style="text-align: left;">1</td><td style="text-align: left;">24 MB</td></tr><tr class="odd"><td style="text-align: left;">0x01660008</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">16 MB</td></tr><tr class="even"><td style="text-align: left;">0x01660009</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">16 MB</td></tr><tr class="odd"><td style="text-align: left;">0x01660003</td><td style="text-align: left;">mobile</td><td style="text-align: left;">4</td><td style="text-align: left;">16 MB</td></tr><tr class="even"><td style="text-align: left;">0x01660004</td><td style="text-align: left;">mobile</td><td style="text-align: left;">1</td><td style="text-align: left;">16 MB</td></tr><tr class="odd"><td style="text-align: left;">0x0166000A</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">16 MB</td></tr><tr class="even"><td style="text-align: left;">0x0166000B</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">16 MB</td></tr></tbody></table><p>原生支持的Dev ID： 0x0152 0x0156 0x0162 0x0166</p><p><strong>推荐的 Framebuffers</strong>：</p><ul><li>Desktop：<ul><li>0x0166000A (default)</li><li>0x01620005</li></ul></li><li>Laptop：<ul><li>0x01660003 (default)</li><li>0x01660009</li><li>0x01660004</li></ul></li><li>空缓冲帧：<ul><li>0x01620007 (default)</li></ul></li></ul><p>注意：</p><p>1.只有 HD4000 能够直接驱动，HD2500需要选择空缓冲帧以使 IQSV正常工作，具体详见https://www.applelife.ru/threads/zavod-intel-quick-sync-video.817923/</p><p>2.如果是6系列主板需要仿冒 device-id 为 3A1E0000，并且打上 <ahref="https://github.com/acidanthera/OpenCorePkg/blob/master/Docs/AcpiSamples/Source/SSDT-IMEI.dsl">SSDT-IMEI</a>补丁。</p><h2 id="intel-hd-graphics-4200-5200-haswell架构">Intel HD Graphics4200-5200 (Haswell架构)</h2><p>支持 OS X 10.9.x 及更新版本。</p><p>Azul FB 列表:</p><table><thead><tr class="header"><th style="text-align: left;">Framebuffer值</th><th style="text-align: left;">Type类型</th><th style="text-align: left;">Connectors输出接口数</th><th style="text-align: left;">TOTAL STOLEN Memory</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0x0C060000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">209 MB</td></tr><tr class="even"><td style="text-align: left;">0x0C160000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">209 MB</td></tr><tr class="odd"><td style="text-align: left;">0x0C260000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">209 MB</td></tr><tr class="even"><td style="text-align: left;">0x04060000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">209 MB</td></tr><tr class="odd"><td style="text-align: left;">0x04160000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">209 MB</td></tr><tr class="even"><td style="text-align: left;">0x04260000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">209 MB</td></tr><tr class="odd"><td style="text-align: left;">0x0D260000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">209 MB</td></tr><tr class="even"><td style="text-align: left;">0x0A160000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">209 MB</td></tr><tr class="odd"><td style="text-align: left;">0x0A260000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">209 MB</td></tr><tr class="even"><td style="text-align: left;">0x0A260005</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">52 MB</td></tr><tr class="odd"><td style="text-align: left;">0x0A260006</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">52 MB</td></tr><tr class="even"><td style="text-align: left;">0x0A2E0008</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">99 MB</td></tr><tr class="odd"><td style="text-align: left;">0x0A16000C</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">99 MB</td></tr><tr class="even"><td style="text-align: left;">0x0D260007</td><td style="text-align: left;">mobile</td><td style="text-align: left;">4</td><td style="text-align: left;">99 MB</td></tr><tr class="odd"><td style="text-align: left;">0x0D220003</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">52 MB</td></tr><tr class="even"><td style="text-align: left;">0x0A2E000A</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">52 MB</td></tr><tr class="odd"><td style="text-align: left;">0x0A26000A</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">52 MB</td></tr><tr class="even"><td style="text-align: left;">0x0A2E000D</td><td style="text-align: left;">desktop</td><td style="text-align: left;">2</td><td style="text-align: left;">131 MB</td></tr><tr class="odd"><td style="text-align: left;">0x0A26000D</td><td style="text-align: left;">desktop</td><td style="text-align: left;">2</td><td style="text-align: left;">131 MB</td></tr><tr class="even"><td style="text-align: left;">0x04120004</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">1 MB</td></tr><tr class="odd"><td style="text-align: left;">0x0412000B</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">1 MB</td></tr><tr class="even"><td style="text-align: left;">0x0D260009</td><td style="text-align: left;">mobile</td><td style="text-align: left;">1</td><td style="text-align: left;">99 MB</td></tr><tr class="odd"><td style="text-align: left;">0x0D26000E</td><td style="text-align: left;">mobile</td><td style="text-align: left;">4</td><td style="text-align: left;">131 MB</td></tr><tr class="even"><td style="text-align: left;">0x0D26000F</td><td style="text-align: left;">mobile</td><td style="text-align: left;">1</td><td style="text-align: left;">131 MB</td></tr></tbody></table><p>原生支持的Dev ID： 0x0d26 0x0a26 0x0a2e 0x0d22 0x0412</p><p><strong>推荐的 Framebuffers</strong>：</p><ul><li>Desktop:<ul><li>0x0D220003 (default)</li></ul></li><li>Laptop:<ul><li>0x0A160000 (default)</li><li>0x0A260005 (recommended)</li><li>0x0A260006 (recommended)</li></ul></li><li>Empty Framebuffer:<ul><li>0x04120004 (default)</li></ul></li></ul><p>注意： 桌面 HD4400 和移动端 HD4200/HD4400/HD4600 需要仿冒 device-id为 12040000</p><h2 id="intel-hd-graphics-5300-6300-broadwell架构">Intel HD Graphics5300-6300 (Broadwell架构)</h2><p>支持 OS X 10.10.2 及更新版本。</p><p>BDW FB 列表：</p><table><thead><tr class="header"><th style="text-align: left;">Framebuffer值</th><th style="text-align: left;">Type类型</th><th style="text-align: left;">Connectors输出接口数</th><th style="text-align: left;">TOTAL STOLEN Memory</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0x16060000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">32 MB</td></tr><tr class="even"><td style="text-align: left;">0x160E0000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">32 MB</td></tr><tr class="odd"><td style="text-align: left;">0x16160000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">32 MB</td></tr><tr class="even"><td style="text-align: left;">0x161E0000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">32 MB</td></tr><tr class="odd"><td style="text-align: left;">0x16260000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">32 MB</td></tr><tr class="even"><td style="text-align: left;">0x162B0000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">32 MB</td></tr><tr class="odd"><td style="text-align: left;">0x16220000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">32 MB</td></tr><tr class="even"><td style="text-align: left;">0x160E0001</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">60 MB</td></tr><tr class="odd"><td style="text-align: left;">0x161E0001</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">60 MB</td></tr><tr class="even"><td style="text-align: left;">0x16060002</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="odd"><td style="text-align: left;">0x16160002</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="even"><td style="text-align: left;">0x16260002</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="odd"><td style="text-align: left;">0x16220002</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="even"><td style="text-align: left;">0x162B0002</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="odd"><td style="text-align: left;">0x16120003</td><td style="text-align: left;">mobile</td><td style="text-align: left;">4</td><td style="text-align: left;">56 MB</td></tr><tr class="even"><td style="text-align: left;">0x162B0004</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="odd"><td style="text-align: left;">0x16260004</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="even"><td style="text-align: left;">0x16220007</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">77 MB</td></tr><tr class="odd"><td style="text-align: left;">0x16260005</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="even"><td style="text-align: left;">0x16260006</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="odd"><td style="text-align: left;">0x162B0008</td><td style="text-align: left;">desktop</td><td style="text-align: left;">2</td><td style="text-align: left;">69 MB</td></tr><tr class="even"><td style="text-align: left;">0x16260008</td><td style="text-align: left;">desktop</td><td style="text-align: left;">2</td><td style="text-align: left;">69 MB</td></tr></tbody></table><p>原生支持的Dev ID: 0x0BD1 0x0BD2 0x0BD3 0x1606 0x160e 0x1616 0x161e0x1626 0x1622 0x1612 0x162b</p><p><strong>推荐的 Framebuffers</strong>:</p><ul><li>Desktop:<ul><li>0x16220007 (default)</li></ul></li><li>Laptop:<ul><li>0x16260006 (default)</li></ul></li></ul><h2 id="intel-hd-graphics-510-580-skylake架构">Intel HD Graphics 510-580(Skylake架构)</h2><p>支持 OS X 10.11.4 及更新版本。</p><p>SKL FB 列表：</p><table><thead><tr class="header"><th style="text-align: left;">Framebuffer值</th><th style="text-align: left;">Type类型</th><th style="text-align: left;">Connectors输出接口数</th><th style="text-align: left;">TOTAL STOLEN Memory</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0x191E0000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="even"><td style="text-align: left;">0x19160000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="odd"><td style="text-align: left;">0x19260000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="even"><td style="text-align: left;">0x19270000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="odd"><td style="text-align: left;">0x191B0000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="even"><td style="text-align: left;">0x193B0000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="odd"><td style="text-align: left;">0x19120000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">56 MB</td></tr><tr class="even"><td style="text-align: left;">0x19020001</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">1 MB</td></tr><tr class="odd"><td style="text-align: left;">0x19170001</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">1 MB</td></tr><tr class="even"><td style="text-align: left;">0x19120001</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">1 MB</td></tr><tr class="odd"><td style="text-align: left;">0x19320001</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">1 MB</td></tr><tr class="even"><td style="text-align: left;">0x19160002</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="odd"><td style="text-align: left;">0x19260002</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="even"><td style="text-align: left;">0x191E0003</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">41 MB</td></tr><tr class="odd"><td style="text-align: left;">0x19260004</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">35 MB</td></tr><tr class="even"><td style="text-align: left;">0x19270004</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="odd"><td style="text-align: left;">0x193B0005</td><td style="text-align: left;">mobile</td><td style="text-align: left;">4</td><td style="text-align: left;">35 MB</td></tr><tr class="even"><td style="text-align: left;">0x191B0006</td><td style="text-align: left;">mobile</td><td style="text-align: left;">1</td><td style="text-align: left;">39 MB</td></tr><tr class="odd"><td style="text-align: left;">0x19260007</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">35 MB</td></tr></tbody></table><p>原生支持的Dev ID: 0x1916 0x191E 0x1926 0x1927 0x1912 0x1932 0x19020x1917 0x193B 0x191B</p><p><strong>推荐的 Framebuffers</strong>:</p><ul><li>Desktop:<ul><li>0x19120000 (default)</li></ul></li><li>Laptop:<ul><li>0x19160000 (default)</li></ul></li><li>Empty Framebuffer:<ul><li>0x19120001 (default)</li></ul></li></ul><h2 id="intel-uhd-graphics-610-650-kaby-lake和amber-lake-y架构">Intel(U)HD Graphics 610-650 (Kaby Lake和Amber Lake Y架构)</h2><p>支持 macOS 10.12.6 及更新版本（其中 UHD617 Amber Lake Y 型号最低版本macOS 10.14.1）。</p><p>KBL/ABL FB 列表：</p><table><thead><tr class="header"><th style="text-align: left;">Framebuffer值</th><th style="text-align: left;">Type类型</th><th style="text-align: left;">Connectors输出接口数</th><th style="text-align: left;">TOTAL STOLEN Memory</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0x591E0000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">35 MB</td></tr><tr class="even"><td style="text-align: left;">0x87C00000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">35 MB</td></tr><tr class="odd"><td style="text-align: left;">0x59160000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">35 MB</td></tr><tr class="even"><td style="text-align: left;">0x59230000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">39 MB</td></tr><tr class="odd"><td style="text-align: left;">0x59260000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">39 MB</td></tr><tr class="even"><td style="text-align: left;">0x59270000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">39 MB</td></tr><tr class="odd"><td style="text-align: left;">0x59270009</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">39 MB</td></tr><tr class="even"><td style="text-align: left;">0x59160009</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">39 MB</td></tr><tr class="odd"><td style="text-align: left;">0x59120000</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">39 MB</td></tr><tr class="even"><td style="text-align: left;">0x591B0000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">39 MB</td></tr><tr class="odd"><td style="text-align: left;">0x591E0001</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">39 MB</td></tr><tr class="even"><td style="text-align: left;">0x59180002</td><td style="text-align: left;">mobile</td><td style="text-align: left;">0</td><td style="text-align: left;">1 MB</td></tr><tr class="odd"><td style="text-align: left;">0x59120003</td><td style="text-align: left;">mobile</td><td style="text-align: left;">0</td><td style="text-align: left;">1 MB</td></tr><tr class="even"><td style="text-align: left;">0x59260007</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">79 MB</td></tr><tr class="odd"><td style="text-align: left;">0x59270004</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="even"><td style="text-align: left;">0x59260002</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="odd"><td style="text-align: left;">0x87C00005</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="even"><td style="text-align: left;">0x591C0005</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="odd"><td style="text-align: left;">0x591B0006</td><td style="text-align: left;">mobile</td><td style="text-align: left;">1</td><td style="text-align: left;">39 MB</td></tr></tbody></table><p>原生支持的Dev ID: - KBL: 0x5912 0x5916 0x591B 0x591C 0x591E 0x59260x5927 0x5923 - ABL: 0x87C0</p><p><strong>推荐的 Framebuffers</strong>:</p><ul><li>Desktop:<ul><li>0x59160000 (default)</li><li>0x59120000 (recommended)</li></ul></li><li>Laptop:<ul><li>0x591B0000 (default)</li></ul></li><li>Empty Framebuffer:<ul><li>0x59120003 (default)</li></ul></li></ul><p>注意： UHD620 需要仿冒 device-id 为 16590000</p><h2 id="intel-uhd-graphics-610-655-coffee-lake和comet-lake架构">IntelUHD Graphics 610-655 (Coffee Lake和Comet Lake架构)</h2><p>支持 macOS 10.14 及更新版本（其中 UHD630 Comet Lake 型号最低版本macOS 10.15.4，推荐10.15.5）。</p><p>CFL/CML FB 列表：</p><table><thead><tr class="header"><th style="text-align: left;">Framebuffer值</th><th style="text-align: left;">Type类型</th><th style="text-align: left;">Connectors输出接口数</th><th style="text-align: left;">TOTAL STOLEN Memory</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0x3EA50009</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="even"><td style="text-align: left;">0x3E920009</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="odd"><td style="text-align: left;">0x3E9B0009</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="even"><td style="text-align: left;">0x3EA50000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="odd"><td style="text-align: left;">0x3E920000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="even"><td style="text-align: left;">0x3E000000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="odd"><td style="text-align: left;">0x3E9B0000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="even"><td style="text-align: left;">0x3EA50004</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="odd"><td style="text-align: left;">0x3EA50005</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="even"><td style="text-align: left;">0x3EA60005</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="odd"><td style="text-align: left;">0x3E9B0006</td><td style="text-align: left;">mobile</td><td style="text-align: left;">1</td><td style="text-align: left;">39 MB</td></tr><tr class="even"><td style="text-align: left;">0x3E9B0008</td><td style="text-align: left;">mobile</td><td style="text-align: left;">1</td><td style="text-align: left;">58 MB</td></tr><tr class="odd"><td style="text-align: left;">0x3E9B0007</td><td style="text-align: left;">desktop</td><td style="text-align: left;">3</td><td style="text-align: left;">58 MB</td></tr><tr class="even"><td style="text-align: left;">0x3E920003</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">1 MB</td></tr><tr class="odd"><td style="text-align: left;">0x3E910003</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">1 MB</td></tr><tr class="even"><td style="text-align: left;">0x3E980003</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">1 MB</td></tr><tr class="odd"><td style="text-align: left;">0x9BC80003</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">1 MB</td></tr><tr class="even"><td style="text-align: left;">0x9BC50003</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">1 MB</td></tr><tr class="odd"><td style="text-align: left;">0x9BC40003</td><td style="text-align: left;">desktop</td><td style="text-align: left;">0</td><td style="text-align: left;">1 MB</td></tr></tbody></table><p>原生支持的Dev ID: - CFL: 0x3E9B 0x3EA5 0x3EA6 0x3E92 0x3E91 0x3E98 -CML: 0x9BC8 0x9BC5 0x9BC4</p><p><strong>推荐的 Framebuffers</strong>:</p><ul><li>Desktop:<ul><li>0x3EA50000 (default)</li><li>0x3E9B0007 (recommended)</li></ul></li><li>Laptop:<ul><li>0x3EA50009 (default)</li></ul></li><li>Empty framebuffer (CFL):<ul><li>0x3E910003 (default)</li></ul></li><li>Empty framebuffer (CML):<ul><li>0x9BC80003 (default)</li></ul></li></ul><p>注意：</p><p>1.macOS 10.14.4除外，九代 CoffeLake 需仿冒 device-id 为923E0000。</p><p>2.Whiskey Lake UHD620 需仿冒 device-id 为 A53E0000。</p><h2 id="intel-iris-plus-graphics-ice-lake架构">Intel Iris Plus Graphics(Ice Lake架构)</h2><p>支持 macOS 10.15.4 及更新版本。</p><p>ICL FB 列表：</p><table><thead><tr class="header"><th style="text-align: left;">Framebuffer值</th><th style="text-align: left;">Type类型</th><th style="text-align: left;">Connectors输出接口数</th><th style="text-align: left;">TOTAL STOLEN Memory</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0xFF050000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">193 MB?</td></tr><tr class="even"><td style="text-align: left;">0x8A710000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">6</td><td style="text-align: left;">193 MB?</td></tr><tr class="odd"><td style="text-align: left;">0x8A700000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">6</td><td style="text-align: left;">193 MB?</td></tr><tr class="even"><td style="text-align: left;">0x8A510000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">6</td><td style="text-align: left;">193 MB?</td></tr><tr class="odd"><td style="text-align: left;">0x8A5C0000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">6</td><td style="text-align: left;">193 MB?</td></tr><tr class="even"><td style="text-align: left;">0x8A5D0000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">6</td><td style="text-align: left;">193 MB?</td></tr><tr class="odd"><td style="text-align: left;">0x8A520000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">6</td><td style="text-align: left;">193 MB?</td></tr><tr class="even"><td style="text-align: left;">0x8A530000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">6</td><td style="text-align: left;">193 MB?</td></tr><tr class="odd"><td style="text-align: left;">0x8A5A0000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">6</td><td style="text-align: left;">193 MB?</td></tr><tr class="even"><td style="text-align: left;">0x8A5B0000</td><td style="text-align: left;">mobile</td><td style="text-align: left;">6</td><td style="text-align: left;">193 MB?</td></tr><tr class="odd"><td style="text-align: left;">0x8A710001</td><td style="text-align: left;">mobile</td><td style="text-align: left;">5</td><td style="text-align: left;">193 MB?</td></tr><tr class="even"><td style="text-align: left;">0x8A700001</td><td style="text-align: left;">mobile</td><td style="text-align: left;">5</td><td style="text-align: left;">193 MB?</td></tr><tr class="odd"><td style="text-align: left;">0x8A510001</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">193 MB?</td></tr><tr class="even"><td style="text-align: left;">0x8A5C0001</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">193 MB?</td></tr><tr class="odd"><td style="text-align: left;">0x8A5D0001</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">193 MB?</td></tr><tr class="even"><td style="text-align: left;">0x8A520001</td><td style="text-align: left;">mobile</td><td style="text-align: left;">5</td><td style="text-align: left;">193 MB?</td></tr><tr class="odd"><td style="text-align: left;">0x8A530001</td><td style="text-align: left;">mobile</td><td style="text-align: left;">5</td><td style="text-align: left;">193 MB?</td></tr><tr class="even"><td style="text-align: left;">0x8A5A0001</td><td style="text-align: left;">mobile</td><td style="text-align: left;">5</td><td style="text-align: left;">193 MB?</td></tr><tr class="odd"><td style="text-align: left;">0x8A5B0001</td><td style="text-align: left;">mobile</td><td style="text-align: left;">5</td><td style="text-align: left;">193 MB?</td></tr><tr class="even"><td style="text-align: left;">0x8A510002</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">193 MB?</td></tr><tr class="odd"><td style="text-align: left;">0x8A5C0002</td><td style="text-align: left;">mobile</td><td style="text-align: left;">3</td><td style="text-align: left;">193 MB?</td></tr><tr class="even"><td style="text-align: left;">0x8A520002</td><td style="text-align: left;">mobile</td><td style="text-align: left;">5</td><td style="text-align: left;">193 MB?</td></tr><tr class="odd"><td style="text-align: left;">0x8A530002</td><td style="text-align: left;">mobile</td><td style="text-align: left;">5</td><td style="text-align: left;">193 MB?</td></tr></tbody></table><p>原生支持的Dev ID: 0xff05 0x8A70 0x8A71 0x8A51 0x8A5C 0x8A5D 0x8A520x8A53 0x8A5A 0x8A5B</p><p><strong>推荐的 Framebuffers</strong>: - Laptop: - 0x8A520000(default)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>农民的时间观念</title>
    <link href="/2021/05/01/%E6%97%B6%E9%97%B4%E6%84%9F/"/>
    <url>/2021/05/01/%E6%97%B6%E9%97%B4%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<p>农民的时间观念，则是在传统农业生产方式和传统社会制度的双重作用之下形成的。在这种时间感之下，农民往往利用事件来记忆时间，以伸缩灵活的事件表述来表达时间。而事件本身的意义则又构成时间记忆的意义中最重要的一部分。农民通过对事件意义的串联，形成完整的记忆和时间体系。以事件为基础意象，将自然与心灵交流后形成的灵活且有总体规律的时间融合到独有的记忆体系中，构成了一个整体的时间感。</p><p>然而，我还应当看到，在发生巨变的当下农村，现代性长驱直入，已经在逐渐改变着农民的时间感。或许在不久的未来，农民的时间观念也会呈现现代性的面貌。毋庸置疑的是，现代性深刻地冲击着传统性并剧烈地改变着当下的中国农村。</p><p>——节选自 黄健《时间感》</p><p>我们深受着城市文明和现代生活的熏陶，在面对农民迟缓的行动节奏和几乎散乱的时间安排时，可能会自然地得出一个结论：农民没有时间观念。本文提到了农民的时间感有四点特性：以时间为标度的循环时间尺度；伸缩性强的弹性时间；与农业生产紧密联系的传统时间；沉淀到具体事项上的灵感知时间。</p><p>我国古代作为长期的农业大国，中国人一直有着安土重迁的传统。《乡土中国》中提到了农业文明是具有乡土性的，农民近乎一辈子依赖于土地。在土地中寻求发展，这种文化形态长期浸染着民族文化心理。农民们的“不紧不慢”的时间感也是一个历史必然产物，至少在城市文明普及前，乡下的人们都保持着这种时间观念。</p><p>随着时间的推移，农民的时间观念也会呈现现代性的面貌，由 flexible变得更加compact。可是仔细想想，城里人似乎早已攀上了制高点，以自己的价值取向用嘲讽的目光打量着农民随和散漫的时间观念。何方不理性审视自身，面对城市化的钢铁洪流，也可以放慢生活的脚步，品杯香茗，感受生活的诗和远方。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>硬核Linux发行版：记录一次完整的Archlinux安装过程</title>
    <link href="/2021/02/25/Archlinux/"/>
    <url>/2021/02/25/Archlinux/</url>
    
    <content type="html"><![CDATA[<h1id="硬核linux发行版记录一次完整的archlinux安装过程">硬核Linux发行版：记录一次完整的Archlinux安装过程</h1><p>参考文档，感谢原作者及Archlinux社区的贡献： - <ahref="https://wiki.archlinux.org/index.php/Arch_Linux">Arch Wiki-ArchLinux</a> - <ahref="https://wiki.archlinux.org/index.php/Installation_guide">ArchWiki-Installation Guide</a> - <ahref="https://wiki.archlinux.org/index.php/Arch_boot_process#Boot_loader">ArchWiki-Bootloader</a> - <ahref="https://blog.csdn.net/cristianojason/article/details/80033330">CSDN-Win10上安装Archlinux(BIOS引导)</a></p><h2 id="intro">Intro</h2><p>当我第一次了解到 Archlinux这独具特色的发行版后，我的大脑是这样想的``( ￣ー￣)</p><pre><code class="hljs">这什么玩意，全程安装无图形界面，NT玩家才会去折腾这玩意。。。滚动更新有什么实际意义？只会导致系统稳定性下降吧。......</code></pre><p>但似乎在很多社交网站或者技术论坛上，总会出现一群 Archlinux的邪教徒的身影，他们高声大喊着：Archlinux,yes!~~。行吧，于是我也抱着试试看的心理开始接触Arch。<em><del>两三天后，不出意外的 真香.</del></em></p><p>ArchWiki 是这样描述的：</p><pre><code class="hljs">Arch Linux is an independently developed, x86-64 general-purpose GNU/Linux distribution that strives to provide the latest stable versions of most software by following a rolling-release model. The default installation is a minimal base system, configured by the user to only add what is purposely required.</code></pre><p>Q：Arch 凭什么能在众多 Linux 中展露锋芒？</p><p>A：Archlinux相较于其他发行版最大的特点其一是高度的可定制性，其二是激进的滚动更新（arolling-release model）。Btw，像 OpenSUSE 和 Arch 的衍生 Manjaro通样运用了滚动更新的包管理器。正是由于 Arch这两大特点使他的安装上手门槛比较高，撇开 Hackintosh 黑苹果不算<del>（职业选手禁止参加比赛！）</del>，Arch和 Fedora可以算得上是操作系统安装难度两大巨头了。</p><p><strong>Notice.</strong>此博文将会记录一次完整的Archlinux安装过程，由于手头没有闲置的设备，将在ParallelsDesktop虚拟机环境下进行。由于Pd中运行Linux模拟了BIOS传统引导的主板且无法修改，但事实上只要不是太老的机型，几乎所有x86平台都采用了UEFI引导方式，这会导致在安装过程中的部分步骤会与实际情况大相径庭（如使用cfdisk分区时的分区策略不同，分区表格式会有mbr+bios和guid+uefi的区分，使用grubbootloader引导系统时也会有较大差异）。综上，如果你想通过这篇文章来学习如何安装Archlinux的话，建议还是在网络上寻找更多的参考资料。我们应该从安装过程中学习到很多内容，而不是仅仅为了得到一个Linux系统而安装，此文只起抛砖引玉的作用。</p><p>废话不多说，开始吧。&lt;(￣︶￣)↗[GO!]</p><h2 id="从官网获取livecd">从官网获取LiveCD</h2><p>进入 Archlinux 的下载页面，推荐下载 BitTorrent 种子文件至本地，再使用Thunder 或 Motrix等第三方磁力下载工具，或者你也可以选择下方国内的镜像源，如清华大学的Tsinghua tuna，一直为 Linux 开源社区提供着优良的镜像服务。Arch团队考虑也挺周全，为用户还提供了Docker 镜像，VM虚拟机，Vagrant（一家主要提供在线Virtualbox虚拟技术服务的国外云平台）镜像等多个版本，这些内容会在Downloads 页面呈现。</p><p>下载好的iso文件可以使用如下命令来校验签名，前提是已安装 <ahref="https://wiki.archlinux.org/index.php/GnuPG">GnuPG</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --keyserver-options auto-key-retrieve --verify archlinux-version-x86_64.iso.sig`<br></code></pre></td></tr></table></figure><p>如果已经有一台配置好的 Arch，也可以用pacman-key（其中version字段名请自行替换）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman-key -v archlinux-version-x86_64.iso.sig<br></code></pre></td></tr></table></figure><p>至目前，最新版本是archlinux-2021.02.01-x86_64.iso。镜像文件已经准备就绪，我们需要一个USB接口的U盘作为安装介质，可以采用rufus，belenaEtcher等工具将iso镜像文件烧录至U盘，开机引导U盘启动。具体步骤不做赘述。</p><h2 id="安装系统">安装系统</h2><h3 id="连接网络和时间同步">连接网络和时间同步</h3><p>如果是BIOS引导，会看到这样的界面，</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux01.png" /></p><p>选中第一项 Arch Linux install medium (x86_64, BIOS)，回车进入 LiveCD系统，实际上就是你U盘里面封装好的Archlinux，系统已经包含了安装所需要的编辑器，网络组建等。经过短暂的跑码系统会将你自动登入root 根用户。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux02.png" /></p><p>注意第四段的文字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">For Wi-Fi, authenticate to the wireless network using the iwctl utility.<br>Ethernet and Wi-Fi connections using DHCP should work automatically.<br></code></pre></td></tr></table></figure><p>这段文字的意思是，如果使用 Wi-Fi 链接英特网请使用 iwctl命令；有线连接即DHCP客户端动态分配IP可以不做任何配置。如果是特殊网络环境，如PPPoe拨号或是校园网，建议使用手机共享USB网络，系统会作为DHCP 网络来处理。</p><p>检查一下网络联通性：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux03.png" /></p><p>可选同步系统时间，采用常用的 NTP 协议（同不同步无所谓），：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">timedatectl set-ntp <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>使用 timedatectl status 检查。</p><h3 id="磁盘分区">磁盘分区</h3><p>BIOS with MBR</p><table><thead><tr class="header"><th style="text-align: left;">Mount point</th><th style="text-align: left;">Partition</th><th style="text-align: left;">Partition type</th><th style="text-align: left;">Suggested size</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">[SWAP]</td><td style="text-align: left;">/dev/swap_partition</td><td style="text-align: left;">Linux swap</td><td style="text-align: left;">More than 512 MiB</td></tr><tr class="even"><td style="text-align: left;">/mnt</td><td style="text-align: left;">/dev/root_partition</td><td style="text-align: left;">Linux</td><td style="text-align: left;">Remainder of the device</td></tr></tbody></table><p>UEFI with GPT</p><table><thead><tr class="header"><th style="text-align: left;">Mount point</th><th style="text-align: left;">Partition</th><th style="text-align: left;">Partition type</th><th style="text-align: left;">Suggested size</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">/mnt/boot or /mnt/efi</td><td style="text-align: left;">/dev/efi_system_partition</td><td style="text-align: left;">EFI system partition</td><td style="text-align: left;">At least 260 MiB</td></tr><tr class="even"><td style="text-align: left;">[SWAP]</td><td style="text-align: left;">/dev/swap_partition</td><td style="text-align: left;">Linux swap</td><td style="text-align: left;">More than 512 MiB</td></tr><tr class="odd"><td style="text-align: left;">/mnt</td><td style="text-align: left;">/dev/root_partition</td><td style="text-align: left;">Linux x86-64 root (/)</td><td style="text-align: left;">Remainder of the device</td></tr></tbody></table><p>以上两个分区参考表格摘自ArchWiki，这里使用第一个方案，但有些注意事项值得一提。</p><ul><li>swap 交换分区的作用：当系统物理 RAM 内存不够用时，系统会将 RAM里的低访问频率的内存对象放置到 swap 分区中。故 swap分区访问速度要远慢于物理内存。</li><li>UEFI 引导的机型在磁盘中已经存在了 ESP 分区，Windows boot manager引导文件会存放在该分区的 EFI 目录下。如果这样，就没必要新建 EFI分区，直接将原有的直接挂载到 /mnt/boot 即可。</li></ul><p>使用 lsblk 命令查看磁盘情况，可以看到 loop0 和 sr0 是当前 LiveCD的虚拟磁盘，我们要做的是在 12GB 的 sda IDE磁盘上安装 Arch：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux04.png" />磁盘工具可以选择 fdisk 或 cfdisk，这里以 cfdisk 作为演示。输入 cfdisk/dev/sda 他会提示选择分区表格式，mbr 即dos。回车进入配置界面，按照表一做好 Linux 分区（ext4）和 swap。如图：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux05.png" />mke2fs 工具可以用于格式化 Linux ext 格式分区（这里是/dev/sda2），但Linux 不仅仅限于 ext4 格式，传统的有 ext234 系列，比较新的有 zfs诸类，zfs 计划在之后唠一唠，这里选择 ext4，毕竟几乎所有发行版都会采用ext4；同时 mkswap 格式化 swap 分区，完成后可以看见如下信息:</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux06.png" />主磁盘分区已准备就绪，命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount /dev/sdax /mnt<br>swapon /dev/sdax<br></code></pre></td></tr></table></figure><p>分别挂载磁盘和应用交换分区。接下来进入安装阶段。</p><h3 id="系统安装">系统安装</h3><p>Arch 完全通过链接互联网来安装基本系统组件，譬如 linux linux-develbase base-devel dhcpcd 等包。由于大陆网络环境的特殊情况，如果使用 arch的官方仓库可能会耗费大把时间，因此切换国内镜像源是完全有必要的。</p><p>LiveCD 早已集成了 vim 编辑器，使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><p>编辑镜像源文件，如图：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux07.png" /></p><p>熟悉 vim 的同学一定会用快捷键 : + /target，快速指定到 target字段的位置。Archlinux 在用户使用 pacman 命令时会按从上到下的顺序索引该mirrorlist 配置文件，我们要将 China 的 Server 地址移至最顶端。使用 n + d+ d 可剪切 n 行的内容，用 p 粘贴。这里使用网易的源：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux08.png" /></p><p>完成后 wq! 退出。pacstrap 工具可为指定分区安装必备的base，linux，linux-firmware包，其他根据需求自选，如base-devel（包含了基本的 gcc 编译器等），dhcpcd网络工具，命令菜单man texinfo，文本编辑器 vi vim nano等。。。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacstrap /mnt base base-devel linux linux-firmware dhcpcd vim nano<br></code></pre></td></tr></table></figure><p>英文好的同学可以看一下官方的说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">The base package does not include all tools from the live installation, <br>so installing other packages may be necessary <span class="hljs-keyword">for</span> a fully functional base system. <br>In particular, consider installing:<br><br>·userspace utilities <span class="hljs-keyword">for</span> the management of file systems that will be used on the system,<br>·utilities <span class="hljs-keyword">for</span> accessing RAID or LVM partitions,<br>·specific firmware <span class="hljs-keyword">for</span> other devices not included <span class="hljs-keyword">in</span> linux-firmware,<br>·software necessary <span class="hljs-keyword">for</span> networking,<br>·a text editor,<br>·packages <span class="hljs-keyword">for</span> accessing documentation <span class="hljs-keyword">in</span> man and info pages: man-db, man-pages and texinfo.<br></code></pre></td></tr></table></figure><p>安装完成后的提示如图</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux09.png" /></p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux10.png" /></p><p>为系统磁盘分区生成 UUID 卷标，UUID 值可使用 lsblkid 查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab<br></code></pre></td></tr></table></figure><h3 id="进入系统并配置基本信息">进入系统并配置基本信息</h3><p>到目前为止，我们仍然使用的是 U 盘 中的 LiveCD 系统，arch-chroot 进入Archlinux！！！</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux11.png" /></p><p>首先要更新时区，ln -sf 创建动态链接至 /etc/localtime，大陆用户请使用Shanghai 标准时间。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux12.png" /></p><p>更新时间，前提是在前面已设置 ntp 协议： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hwclock --systohc<br></code></pre></td></tr></table></figure> 编辑语言文件/etc/locale.gen 并且解注释 en_US 和zh_CN，具体操作不赘述。保存完成后更新语言：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">locale-gen<br></code></pre></td></tr></table></figure><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux13.png" /></p><p>新建文件/etc/locale.conf，同时添加以下内容（请不要使用中文作为默认语言）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">LANG=en_US.UTF-8<br></code></pre></td></tr></table></figure><p>接下来配置本地网络，arch 的 hosts 文件存在于 /etc/hosts，vim编辑以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1localhost<br>::1localhost<br>127.0.1.1myhostname.localdomainmyhostname<br></code></pre></td></tr></table></figure><p>myhostname 为网络主机名，请新建文件 /etc/hostname 并添加 myhostname字段名，请自行替换主机名。 如：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux14.png" /></p><p>⚠️如果你拥有固定的公网 ip，用它来替换127.0.0.1（我相信大部分私人电脑都搞不到固定公网ip✧(≖ ◡ ≖✿) ）</p><p>mkinitcpio -P 生成 initramfs img 镜像，其实这个过程在 pacstrap时已经跑了一遍。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux15.png" /></p><h3 id="普通用户组的添加">普通用户组的添加</h3><p>首先 passwd 设置 root 密码，密码不会显示明文，输入后回车即可。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux16.png" /></p><p>wheel 组中添加新用户，编辑 /etc/sudoers 文件解注释 %wheel，这样username 用户就可以使用 sudo 来获得 root权限了。同样的，passwd设置密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">useradd -m -G wheel username<br>passwd username<br></code></pre></td></tr></table></figure><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux22.png" /></p><h3 id="grub-系统引导">grub 系统引导</h3><p>Linux 的系统引导程序数不胜数，eg. grub sysLinux rEFIndClover。一般情况首选 grub，如果是 BIOS 传统启动需要Grub-Legacy（官方开源仓库已经移除，需通过 AUR 安装） 或 Grub 和os-prober，UEFI 请用 grub 和 efibootmgr。这里以 BIOS 为例。</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux17.png" /></p><p>grub-install 进行安装，不出意外能看到成功信息：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux18.png" />exit 退出返回 LiveCD，卸载分区，reboot重启，系统基本组件就安装完成了！！！</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux19.png" /></p><h2 id="图形界面安装">图形界面安装</h2><p>kde，gnome，xfce，dde 属于 DE（Desktop Environment）；i3，dwm属于窗口管理器。Archlinux的高度可自定义性使我们可任意选择自己喜欢的图形界面。</p><p>本篇博客以基于 qt5 精美的 KDE 作为桌面环境 ~~（Gnome党不要打我ヽ(ﾟ∀ﾟ*)ﾉ━━━ｩ♪ ）~~</p><p>补充：犹且记得第一次实体机安装 Arch 时，现实并没有想象中的美好。首次grub引导进入系统后网络问题可能是最大的判脚石，没有通用的解决方案，<del>请自行上网搜索吧行不行就看你是欧皇还是非酋了</del>，设想会另写一篇说一下网络问题和双显卡驱动。</p><p>确保网络是通畅的，我演示时只需 systemed 开机启动 dhcpcd服务即可：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux20.png" /></p><p>emm.现在回到正题。</p><p>安装 Xorg 服务和 KDE-plasma 还有启动管理器 sddm，不建议安装 kde的全家桶 kde-applications（非常臃肿！！），这里只装了 dolphin 和 konsole终端。</p><p>如图（截图时已提前安装了 Xorg）：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux24.png" /></p><p>systemctl 让 sddm 开机自启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> sddm<br></code></pre></td></tr></table></figure><p>最后一步了，配置系统字体，安装中文文泉驿 microhei 和英文 dejavu：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux25.png" /></p><p>重启！你就能看到久违的图形化桌面了。真可谓“山重水复疑无路，柳暗花明又一村”～</p><h2 id="后续优化">后续优化</h2><p>有两点内容需要知道： 1.yay 2.archlinuxcn 源</p><p>yay 是继神器 yaourt 后又一个 AUR 仓库包管理器，拥有 pacman的几乎所有功能并且能够抓取 AUR 仓库软件。输入 pacman -S yay即可安装。</p><p>archlinuxcn 顾名思义，是中国 Arch 用户自行维护的仓库。由于所有 Linux发行版仓库中都只有开源软件，像 Google Chrome商业软件时不可能包含在内的。archlinuxcn源早已编译好了很多常用的软件：Chrome，WPSOffice，Neteasecloudmusic，搜狗输入法等等，确实能带来不少便利。请参考清华大学的文档安装：https://mirrors.tuna.tsinghua.edu.cn/help/archlinuxcn/</p><p>高中生活时间很紧，一个星期只有一天能赶一点文字。这篇博客真的写了很长时间，满打满算1个半月，贴点图片纪念一下吧：</p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux27.png" /></p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux28.png" /></p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux29.png" /></p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux30.png" /></p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux31.png" /></p><p><imgsrc="https://funciaty.oss-cn-qingdao.aliyuncs.com/pic/Archlinux32.png" />## Outro 按照 Archlinux官方的介绍，他们团队维护着Arch一直秉持着五个理念：</p><pre><code class="hljs">Simplicity， Modernity， Pragmatism， User Centrality， Versatility</code></pre><p>简而言之：Keep It Simple, Stupid.</p><p>保持简约，一目了然再好不过了。</p><p>或许从中也能得到启发：生活固然不简单，即使这样也要简单的生活。</p><p>Billy Shao,</p><p>2/24/2021记.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>简谈C++高精度算法</title>
    <link href="/2020/03/11/cppHighAlgorithm/"/>
    <url>/2020/03/11/cppHighAlgorithm/</url>
    
    <content type="html"><![CDATA[<p>第一篇博文，&lt;(￣︶￣)↗[GO!]</p><p>高精度是一类重要且基础的算法，主要应用场景是在进行大数运算时，如果使用语言编译器内置的基本数据结构的话肯定会溢出。拿C++来说，最大的整型longlong大小也只有2的64次方。（当然python玩家不用担心这个问题）。</p><p>这时候高精度算法就体现了其价值：我们将输入的整型变量每一位存储在数组中，运算时直接通过数组来进行。</p><p>方便运算时低位运算进位至高位，可以将大数倒序存储在数组之中：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>], len;<br>string num;<br>cin &gt;&gt; num;<br>len = num.<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>a[i] = num[len - i] - <span class="hljs-string">&#x27;0&#x27;</span>;  <br><span class="hljs-comment">// 读入的数字是string，这里char隐式转换为int</span><br>&#125;<br></code></pre></td></tr></table></figure> 这样就简单的完成了读入部分。 高精度数输出的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>cout &lt;&lt; a[i];<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h1 id="高精度加单精度">高精度加单精度</h1><p>回顾小学二年级学过的竖式加法 （逐渐毕导化），你就会发现实现的思路：<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap"><br> <span class="hljs-number"> 2 </span>3<span class="hljs-number"> 1 </span>1  9<br>+).        1<br>—————————————<br> <span class="hljs-number"> 2 </span>3<span class="hljs-number"> 1 </span>1 10<br>即<br> <span class="hljs-number"> 2 </span>3<span class="hljs-number"> 1 </span>1 9<br>+).       1<br>—————————————<br> <span class="hljs-number"> 2 </span>3<span class="hljs-number"> 1 </span>2 0<br></code></pre></td></tr></table></figure>同时要注意进位时注意最高位的处理，并且同时更新len的值。这里while语句会重复判断最高位+1是否为0（注意：我们已经将数组a用memset初始化为0）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>], len;<br>    string num;<br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a));<br>    cin &gt;&gt; num;<br>    len = num.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>        a[i] = num[len - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> x;<br>    cin &gt;&gt; x;<br>    a[<span class="hljs-number">1</span>] += x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>        a[i + <span class="hljs-number">1</span>] += a[i] / <span class="hljs-number">10</span>;<br>        a[i] %= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (a[len + <span class="hljs-number">1</span>]) &#123;<br>        len++;<br>        a[len + <span class="hljs-number">1</span>] += a[len] / <span class="hljs-number">10</span>;<br>        a[len] %= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        cout &lt;&lt; a[i];<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高精度加高精度">高精度加高精度</h1><p>和上一个案例相比，唯一的不同就是求和的过程。我们这里不再是只让存贮高精度的数组的第一位加上x，而是让每一位都加上另外一个高精度对应位置上的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a1[<span class="hljs-number">100</span>], len1, a2[<span class="hljs-number">100</span>], len2;<br>len1 = <span class="hljs-built_in">max</span>(len1, len2); <span class="hljs-comment">// 注意引入 cmath库</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>a1[i] += a2[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>最高位处理方法相同，这里直接放出代码。 （数组大小有点夸张哈）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a1[<span class="hljs-number">999999999</span>], len1, a2[<span class="hljs-number">999999999</span>], len2;<br>    string num1, num2;<br>    cin &gt;&gt; num1 &gt;&gt; num2;<br>    len1 = num1.<span class="hljs-built_in">length</span>();<br>    len2 = num2.<span class="hljs-built_in">length</span>();<br><br>    <span class="hljs-built_in">memset</span>(a1, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a1));<br>    <span class="hljs-built_in">memset</span>(a2, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a2));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>        a1[i] = num1[len1 - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len2; i++) &#123;<br>        a2[i] = num2[len2 - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    len1 = <span class="hljs-built_in">max</span>(len1, len2);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>        a1[i] += a2[i];<br>        a1[i + <span class="hljs-number">1</span>] += a1[i] / <span class="hljs-number">10</span>;<br>        a1[i] %= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (a1[len1 + <span class="hljs-number">1</span>]) &#123;<br>        len1++;<br>        a1[len1 + <span class="hljs-number">1</span>] += a1[len1] / <span class="hljs-number">10</span>;<br>        a1[len1] %= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len1; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        cout &lt;&lt; a1[i];<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高精度减单精度">高精度减单精度</h1><p>emm..这里暂时不考虑结果出现负值的情况。 简单的思路：</p><p>1.将高精度的最后一位减去单精度整数，当前指向最后一位</p><p>2.如果当前位上的数小于0，就让当前指向的前一位减去1，并让当前位加上10，直到当前位上的数不小于0</p><p>3.向前移动一位，继续执行第二步操作。</p><p>除了上述过程和加法有所差异以外，最后的长度处理也与加法有所不同。进行相减操作以后，高精度整数的总长度有可能会变小，所以需要判断是否当前高精度整数的最高位已经是0，如果是0则需要让总长度减去1。</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a[<span class="hljs-number">1</span>] -= x;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;= len; i++) &#123;<br><span class="hljs-keyword">while</span> (a[i] &lt; <span class="hljs-number">0</span>) &#123;<br>a[i + <span class="hljs-number">1</span>]--;<br>a[i] += <span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">1</span> &amp;&amp; a[len] == <span class="hljs-number">0</span>) &#123;<br>len --;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高精度减高精度">高精度减高精度</h1><p>不同之处在于，我们需要先对两个数的每- -位进行减法操作，并且在最后由于长度的减少值可能不止1，所以需要不断地判断最高位是否已经被减到0。并且，因为每一位上的数均在0…9之间，所以之前的while(a1[i] &lt; 0)写成if(a1[i] &lt; 0)就可以了。当然，这里用while也是没有任何问题的。 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a1[<span class="hljs-number">100</span>], len1, a2[<span class="hljs-number">100</span>], len2;<br>    <span class="hljs-built_in">memset</span>(a1, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a1));<br>    <span class="hljs-built_in">memset</span>(a2, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a2));<br>    string num1, num2;<br>    cin &gt;&gt; num1 &gt;&gt; num2;<br>    <span class="hljs-keyword">if</span> (num1.<span class="hljs-built_in">length</span>() &lt; num2.<span class="hljs-built_in">length</span>() || num1.<span class="hljs-built_in">length</span>() == num2.<span class="hljs-built_in">length</span>() &amp;&amp; num1 &lt; num2) &#123;<br>        <span class="hljs-built_in">swap</span>(num1, num2);<br>        cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;<br>    &#125;<br>    <br>    len1 = num1.<span class="hljs-built_in">length</span>();<br>    len2 = num2.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>        a1[i] = num1[len1 - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len2; i++) &#123;<br>        a2[i] = num2[len2 - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;                                                                      <br>len1 = <span class="hljs-built_in">max</span>(len1, len2);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>        a1[i] -= a2[i];<br>        <span class="hljs-keyword">if</span> (a1[i] &lt; <span class="hljs-number">0</span>) &#123;<br>            a1[i + <span class="hljs-number">1</span>]--;<br>            a1[i] += <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (len1 &gt; <span class="hljs-number">1</span> &amp;&amp; a1[len1] == <span class="hljs-number">0</span>) &#123;<br>        len1--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len1; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        cout &lt;&lt; a1[i];<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>高精度乘单精度跳过吧，咱们直接看～</p><h1 id="高精度乘高精度">高精度乘高精度</h1><p>高精度乘高精度是最值得探讨的一部分，所以，和之前不同的关键，在于如何把处理进位之前每一位上的乘积总和求出来。我们再用一个例子来看一看:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">      3   2   1<br>x)        2   1<br>————————————————<br>     3<span class="hljs-number">*1</span> 2<span class="hljs-number">*1</span> 1<span class="hljs-number">*1</span><br> 3<span class="hljs-number">*2</span> 2<span class="hljs-number">*2</span> 1<span class="hljs-number">*2</span><br>————————————————<br> [4] [3] [2] [1]<br></code></pre></td></tr></table></figure><p>我们发现，对于最终结果下标为i的位置来说，它包括的乘积对应的两个下标之和均为i+1。因此，我们可以另外开辟一个新的数组来保存高精度乘法的结果，然后通过如下的方式来计算高精度乘法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;<br>a[i + j - <span class="hljs-number">1</span>] += a1[i] * a2[j];<br>&#125;<br>&#125;<br>len = len1 + len2 - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a1[<span class="hljs-number">100</span>], len1, a2[<span class="hljs-number">100</span>], len2;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">200</span>], len;<br>    <span class="hljs-built_in">memset</span>(a1, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a1));<br>    <span class="hljs-built_in">memset</span>(a2, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a2));<br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a));<br>    string num1, num2;<br>    cin &gt;&gt; num1;<br>    len1 = num1.<span class="hljs-built_in">length</span>();<br>    cin &gt;&gt; num2;<br>    len2 = num2.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>        a1[i] = num1[len1 - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len2; i++) &#123;<br>        a2[i] = num2[len2 - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;<br>        a[i + j - <span class="hljs-number">1</span>] += a1[i] * a2[j];<br>    &#125;<br>    &#125;<br>    len = len1 + len2 - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>        a[i + <span class="hljs-number">1</span>] += a[i] / <span class="hljs-number">10</span>;<br>        a[i] %= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (a[len + <span class="hljs-number">1</span>]) &#123;<br>        len++;<br>        a[len + <span class="hljs-number">1</span>] += a[len] / <span class="hljs-number">10</span>;<br>        a[len] %= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        cout &lt;&lt; a[i];<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>小结一下暂时不讨论除法和模运算，总的思路就是用int数组倒序读入每一位上的数，类比数学运算可以得到运算规则。处理乘法时务必要重新做一个变量存储result。</p><p>源码可以去参考我的Github仓库：https://github.com/Billy233/cpp_HighAccuracy</p><p>Billy Shao,</p><p>3/11/2020记.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
